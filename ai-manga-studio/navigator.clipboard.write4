import os

files_content = {}

# 1. src/features/editor/StoryEditor.tsx
# UX改修: Motion Bridge Protocolに基づき、動画間のプロンプト生成を抑制
files_content['src/features/editor/StoryEditor.tsx'] = """import React, { useState } from 'react';
import { 
  Box, Typography, Button, Paper, Chip, IconButton, Stack, CircularProgress, 
  Menu, MenuItem, ListItemIcon, ListItemText, Dialog, DialogTitle, DialogContent, 
  DialogActions, FormControl, FormLabel, RadioGroup, FormControlLabel, Radio, 
  Switch, ToggleButtonGroup, ToggleButton, Divider, TextField, Tooltip
} from '@mui/material';
import { v4 as uuidv4 } from 'uuid';

// Icons
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ImageIcon from '@mui/icons-material/Image';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import PlayCircleOutlineIcon from '@mui/icons-material/PlayCircleOutline';
import PictureAsPdfIcon from '@mui/icons-material/PictureAsPdf';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import CompressIcon from '@mui/icons-material/Compress';
import HighQualityIcon from '@mui/icons-material/HighQuality';
import DownloadIcon from '@mui/icons-material/Download';
import CropPortraitIcon from '@mui/icons-material/CropPortrait';
import CropLandscapeIcon from '@mui/icons-material/CropLandscape';
import FolderZipIcon from '@mui/icons-material/FolderZip';
import InsertPhotoIcon from '@mui/icons-material/InsertPhoto';
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline';
import MovieIcon from '@mui/icons-material/Movie';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import DeleteIcon from '@mui/icons-material/Delete';

// Redux
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import { setCurrentProject, updateProjectAsset, addStoryBlock, removeStoryBlock, updateBlockPrompt } from '../projects/projectSlice';
import { addAsset } from '../assets/assetSlice';

// Components & Utils
import ImageGenModal from '../../components/ImageGenModal';
import MangaViewer from '../../components/MangaViewer';
import { generatePDF } from '../../utils/pdfExporter';
import type { PDFExportOptions } from '../../utils/pdfExporter';
import { generateImages } from '../../utils/imageExporter';
import type { AspectRatio } from '../../utils/imageExporter';
import { ImageBlock, VideoBlock } from '../../types';

interface StoryEditorProps {
  getAssetUrl: (id: string | null) => string | undefined;
}

const StoryEditor: React.FC<StoryEditorProps> = ({ getAssetUrl }) => {
  const dispatch = useAppDispatch();
  const project = useAppSelector(state => state.projects.currentProject);
  const allAssets = useAppSelector(state => state.assets.items);

  // Modal State
  const [modalOpen, setModalOpen] = useState(false);
  const [viewerOpen, setViewerOpen] = useState(false);
  const [currentPrompt, setCurrentPrompt] = useState('');
  const [targetId, setTargetId] = useState<'cover' | string>('cover');

  // PDF Export State
  const [isExporting, setIsExporting] = useState(false);
  const [exportMessage, setExportMessage] = useState('');
  const [pdfMenuAnchor, setPdfMenuAnchor] = useState<null | HTMLElement>(null);

  // Image Export Modal State
  const [imgExportOpen, setImgExportOpen] = useState(false);
  const [exportRatio, setExportRatio] = useState<AspectRatio>('9:16');
  const [exportWithText, setExportWithText] = useState(true);
  const [exportMode, setExportMode] = useState<'zip' | 'single'>('zip');

  if (!project) return null;

  // --- Handlers ---

  const handleBack = () => {
    dispatch(setCurrentProject(null));
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  // PDF Export
  const handlePdfMenuOpen = (e: React.MouseEvent<HTMLElement>) => setPdfMenuAnchor(e.currentTarget);
  const handlePdfMenuClose = () => setPdfMenuAnchor(null);
  
  const handleExportPDF = async (options: PDFExportOptions) => {
    handlePdfMenuClose();
    setIsExporting(true);
    setExportMessage("PDF準備中...");
    setTimeout(async () => {
      await generatePDF(project, allAssets, (msg) => setExportMessage(msg), options);
      setIsExporting(false);
      setExportMessage('');
    }, 100);
  };

  // Image Export
  const handleImageExport = async () => {
    setImgExportOpen(false);
    setIsExporting(true);
    setExportMessage("画像生成中...");
    
    setTimeout(async () => {
      await generateImages(
        project, 
        allAssets, 
        { ratio: exportRatio, withText: exportWithText, mode: exportMode }, 
        (msg) => setExportMessage(msg)
      );
      setIsExporting(false);
      setExportMessage('');
    }, 100);
  };

  // Image Gen Handlers
  const handleGenStart = (prompt: string, target: 'cover' | string) => {
    const fullPrompt = `(Masterpiece, Best Quality), Manga Style. ${prompt}`;
    setCurrentPrompt(fullPrompt);
    setTargetId(target);
    setModalOpen(true);
  };

  const handleGenFinish = async (files: FileList) => {
    if (files.length > 0) {
      const action = await dispatch(addAsset({ file: files[0], category: 'generated' }));
      if (addAsset.fulfilled.match(action)) {
        const newAssetId = action.payload.id;
        dispatch(updateProjectAsset({
          projectId: project.id,
          type: targetId === 'cover' ? 'cover' : 'block',
          blockId: targetId !== 'cover' ? targetId : undefined,
          assetId: newAssetId
        }));
        setModalOpen(false);
      }
    }
  };

  const handleDropAssign = async (e: React.DragEvent, target: 'cover' | string) => {
    e.preventDefault();
    const assetId = e.dataTransfer.getData('assetId');
    if (assetId) {
      dispatch(updateProjectAsset({
        projectId: project.id,
        type: target === 'cover' ? 'cover' : 'block',
        blockId: target !== 'cover' ? target : undefined,
        assetId: assetId
      }));
    } else if (e.dataTransfer.files.length > 0) {
      // 素材としてアップロード
      const action = await dispatch(addAsset({ file: e.dataTransfer.files[0], category: 'material' }));
      if (addAsset.fulfilled.match(action)) {
        dispatch(updateProjectAsset({
          projectId: project.id,
          type: target === 'cover' ? 'cover' : 'block',
          blockId: target !== 'cover' ? target : undefined,
          assetId: action.payload.id
        }));
      }
    }
  };

  // --- Video Block Handlers ---

  const handleAddVideoBlock = (index: number) => {
    const newBlock: VideoBlock = {
      id: uuidv4(),
      type: 'video',
      prompt: '',
      assignedAssetId: null
    };
    dispatch(addStoryBlock({ projectId: project.id, index, block: newBlock }));
  };

  const handleRemoveBlock = (blockId: string) => {
    if(window.confirm('このブロックを削除しますか？')) {
      dispatch(removeStoryBlock({ projectId: project.id, blockId }));
    }
  };

  const handleGenerateBridgePrompt = (index: number) => {
    const currentBlock = project.storyboard[index] as VideoBlock;
    if (!currentBlock) return;

    // 前後のコンテキスト取得
    const prevBlock = project.storyboard[index - 1];
    const nextBlock = project.storyboard[index + 1];

    const prevDesc = (prevBlock && prevBlock.type === 'image') ? prevBlock.sceneDescription : 'Start';
    const nextDesc = (nextBlock && nextBlock.type === 'image') ? nextBlock.sceneDescription : 'End';

    const prompt = `Create a smooth video transition.
[Start Scene]: ${prevDesc}
[End Scene]: ${nextDesc}
[Style]: ${project.gachaResult.themeA}, ${project.gachaResult.themeB}
[Motion]: Morphing, Cinematic camera movement.`;

    dispatch(updateBlockPrompt({ projectId: project.id, blockId: currentBlock.id, prompt }));
    copyToClipboard(prompt);
  };

  // --- Render Helpers ---

  const renderImagePlaceholder = (assetId: string | null, onClick: () => void, onDrop: (e: React.DragEvent) => void, label: string) => {
    const url = getAssetUrl(assetId);
    return (
      <Box
        sx={{
          width: 140, aspectRatio: '2/3', bgcolor: 'black', borderRadius: 1,
          border: url ? '1px solid' : '2px dashed',
          borderColor: url ? 'divider' : 'text.disabled',
          overflow: 'hidden', cursor: 'pointer', position: 'relative', flexShrink: 0,
          '&:hover': { borderColor: 'primary.main' }
        }}
        onClick={onClick}
        onDragOver={(e) => e.preventDefault()}
        onDrop={onDrop}
      >
        {url ? (
          <Box component="img" src={url} alt="asset" sx={{ width: '100%', height: '100%', objectFit: 'cover' }} />
        ) : (
          <Box sx={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', color: 'text.disabled', p: 1, textAlign: 'center' }}>
            <ImageIcon />
            <Typography variant="caption">{label}</Typography>
          </Box>
        )}
      </Box>
    );
  };

  const renderVideoBlock = (block: VideoBlock, index: number) => {
    const url = getAssetUrl(block.assignedAssetId);

    // ★Ticket #3 UX改修: 前後が静止画でない場合は生成ボタンを無効化
    const prevBlock = project.storyboard[index - 1];
    const nextBlock = project.storyboard[index + 1];
    const isPrevImage = prevBlock?.type === 'image';
    const isNextImage = nextBlock?.type === 'image';
    const canGenerate = isPrevImage && isNextImage;
    const tooltipText = canGenerate 
        ? "前後の文脈からプロンプト生成" 
        : "動画と動画の間をつなぐ生成はサポートしていません";

    return (
      <Paper 
        key={block.id} 
        variant="outlined" 
        sx={{ 
          p: 2, display: 'flex', gap: 2, bgcolor: '#0f172a', borderColor: 'primary.dark',
          borderStyle: 'dashed', position: 'relative'
        }}
      >
        <Box sx={{ width: 40, display: 'flex', flexDirection: 'column', alignItems: 'center', pt: 1, color: 'primary.main' }}>
          <MovieIcon />
        </Box>
        
        {/* Video Preview / Dropzone */}
        <Box
          sx={{
             width: 240, aspectRatio: '16/9', bgcolor: 'black', borderRadius: 1,
             border: url ? '1px solid' : '2px dashed',
             borderColor: url ? 'primary.main' : 'text.disabled',
             overflow: 'hidden', position: 'relative', flexShrink: 0,
             display: 'flex', alignItems: 'center', justifyContent: 'center'
          }}
          onDragOver={(e) => e.preventDefault()}
          onDrop={(e) => handleDropAssign(e, block.id)}
        >
           {url ? (
             <video src={url} loop muted autoPlay style={{ width: '100%', height: '100%', objectFit: 'cover' }} />
           ) : (
             <Typography variant="caption" color="text.disabled">Drop Video Here</Typography>
           )}
        </Box>

        {/* Controls */}
        <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 1 }}>
           <Box sx={{ display: 'flex', gap: 1 }}>
             <TextField 
                fullWidth size="small" multiline maxRows={3} 
                placeholder="Video Prompt..."
                value={block.prompt}
                onChange={(e) => dispatch(updateBlockPrompt({ projectId: project.id, blockId: block.id, prompt: e.target.value }))}
                sx={{ 
                  '& .MuiOutlinedInput-root': { color: 'primary.light', fontFamily: 'monospace', fontSize: '0.8rem' },
                  '& .MuiOutlinedInput-notchedOutline': { borderColor: 'rgba(99, 102, 241, 0.3)' }
                }}
             />
             <Tooltip title={tooltipText}>
               {/* DisabledなボタンにTooltipを出すためspanで囲む */}
               <span>
                 <Button 
                   variant="outlined" sx={{ minWidth: 40, px: 1 }} 
                   onClick={() => handleGenerateBridgePrompt(index)}
                   disabled={!canGenerate}
                 >
                   <AutoFixHighIcon fontSize="small" />
                 </Button>
               </span>
             </Tooltip>
           </Box>
           <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
             <Button 
               size="small" color="error" startIcon={<DeleteIcon />} 
               onClick={() => handleRemoveBlock(block.id)}
             >
               削除
             </Button>
           </Box>
        </Box>
      </Paper>
    );
  };

  const renderAddBridge = (index: number) => (
    <Box sx={{ display: 'flex', alignItems: 'center', py: 1.5 }}>
       <Divider sx={{ flex: 1, borderColor: 'rgba(255,255,255,0.05)' }} />
       <Button 
         size="small" variant="outlined" startIcon={<AddCircleOutlineIcon />}
         onClick={() => handleAddVideoBlock(index)}
         sx={{ 
            mx: 2, borderRadius: 10, px: 2, textTransform: 'none',
            borderColor: 'rgba(255,255,255,0.1)', 
            color: 'text.secondary',
            fontSize: '0.75rem',
            '&:hover': { 
                borderColor: 'primary.main', 
                color: 'primary.main',
                bgcolor: 'rgba(99, 102, 241, 0.05)' 
            }
         }}
       >
         動画を追加
       </Button>
       <Divider sx={{ flex: 1, borderColor: 'rgba(255,255,255,0.05)' }} />
    </Box>
  );

  return (
    <Box sx={{ height: '100%', overflowY: 'auto', p: 3, paddingBottom: '8rem' }}>
      
      {/* Header Bar */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
        <Button startIcon={<ArrowBackIcon />} onClick={handleBack} sx={{ color: 'text.secondary' }}>
          リストに戻る
        </Button>
        
        <Stack direction="row" spacing={2}>
          <Button 
            variant="outlined" 
            color="info"
            startIcon={isExporting ? <CircularProgress size={20} /> : <DownloadIcon />}
            onClick={() => setImgExportOpen(true)}
            disabled={isExporting}
          >
            {isExporting ? exportMessage : "画像DL"}
          </Button>

          <Box>
            <Button 
              variant="outlined" color="primary"
              startIcon={isExporting ? <CircularProgress size={20} /> : <PictureAsPdfIcon />}
              endIcon={!isExporting && <KeyboardArrowDownIcon />}
              onClick={handlePdfMenuOpen}
              disabled={isExporting}
            >
              PDF出力
            </Button>
            <Menu anchorEl={pdfMenuAnchor} open={Boolean(pdfMenuAnchor)} onClose={handlePdfMenuClose}>
              <MenuItem onClick={() => handleExportPDF({ scale: 2, quality: 0.9 })}>
                <ListItemIcon><HighQualityIcon fontSize="small" /></ListItemIcon>
                <ListItemText primary="高画質 (通常)" secondary="綺麗な印刷向け" />
              </MenuItem>
              <MenuItem onClick={() => handleExportPDF({ scale: 1, quality: 0.6, filenameSuffix: '_light' })}>
                <ListItemIcon><CompressIcon fontSize="small" /></ListItemIcon>
                <ListItemText primary="軽量版 (圧縮)" secondary="共有向け" />
              </MenuItem>
            </Menu>
          </Box>

          <Button variant="contained" color="success" startIcon={<PlayCircleOutlineIcon />} onClick={() => setViewerOpen(true)}>
            プレビュー
          </Button>
        </Stack>
      </Box>

      {/* Main Editor Content */}
      <Paper variant="outlined" sx={{ p: 0, mb: 4, overflow: 'hidden', bgcolor: 'background.paper' }}>
        <Box sx={{ p: 3, borderBottom: 1, borderColor: 'divider', background: 'linear-gradient(to bottom right, #0f172a, rgba(49, 46, 129, 0.2))' }}>
          <Typography variant="h5" fontWeight="bold" gutterBottom>{project.title}</Typography>
          <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
            <Chip label={project.gachaResult.themeA} color="primary" variant="outlined" size="small" />
            <Chip label={project.gachaResult.themeB} color="primary" variant="outlined" size="small" />
            <Chip label={`★ ${project.gachaResult.secretIngredient}`} color="warning" variant="outlined" size="small" />
          </Stack>
          <Typography variant="body2" color="text.secondary" sx={{ fontStyle: 'italic', borderLeft: 3, borderColor: 'primary.main', pl: 1 }}>
            {project.synopsis}
          </Typography>
        </Box>
        <Box sx={{ p: 3, display: 'flex', gap: 3 }}>
          {renderImagePlaceholder(project.coverAssetId, () => handleGenStart(project.coverImagePrompt, 'cover'), (e) => handleDropAssign(e, 'cover'), "表紙生成")}
          <Box sx={{ flex: 1, bgcolor: 'rgba(2, 6, 23, 0.3)', p: 2, borderRadius: 1, border: 1, borderColor: 'divider' }}>
            <Typography variant="caption" fontWeight="bold" color="text.secondary" display="block" mb={1}>EDITOR'S NOTE</Typography>
            <Typography variant="body2" color="text.secondary">{project.editorNote}</Typography>
          </Box>
        </Box>
      </Paper>

      <Typography variant="subtitle1" fontWeight="bold" sx={{ mb: 2, color: 'text.secondary' }}>ストーリーボード (全{project.storyboard.length}ブロック)</Typography>
      <Stack spacing={0}>
        {project.storyboard.map((block, idx) => {
          const isImage = block.type === 'image';
          return (
             <React.Fragment key={block.id}>
               {/* 1. Render Block */}
               {isImage ? (
                  <Paper variant="outlined" sx={{ p: 2, display: 'flex', gap: 2, '&:hover': { borderColor: 'text.secondary' } }}>
                    <Typography variant="h5" fontWeight="bold" color="text.disabled" sx={{ width: 40, textAlign: 'center', pt: 1 }}>{(block as ImageBlock).pageNumber}</Typography>
                    {renderImagePlaceholder(block.assignedAssetId, () => handleGenStart((block as ImageBlock).imagePrompt, block.id), (e) => handleDropAssign(e, block.id), "画像生成")}
                    <Box sx={{ flex: 1, minWidth: 0 }}>
                      <Typography variant="subtitle2" fontWeight="bold" gutterBottom>{(block as ImageBlock).sceneDescription}</Typography>
                      <Paper variant="outlined" sx={{ p: 1.5, mb: 1, bgcolor: '#020617', borderLeft: 3, borderColor: 'primary.main' }}><Typography variant="body2" color="primary.light">{(block as ImageBlock).dialogue}</Typography></Paper>
                      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <Typography variant="caption" fontFamily="monospace" color="text.disabled" noWrap sx={{ maxWidth: '80%', bgcolor: 'rgba(255,255,255,0.05)', px: 1, borderRadius: 0.5 }}>{(block as ImageBlock).imagePrompt}</Typography>
                        <IconButton size="small" onClick={() => copyToClipboard((block as ImageBlock).imagePrompt)}><ContentCopyIcon fontSize="small" /></IconButton>
                      </Box>
                    </Box>
                  </Paper>
               ) : (
                  renderVideoBlock(block as VideoBlock, idx)
               )}

               {/* 2. Render Bridge Button (between blocks) */}
               {renderAddBridge(idx + 1)}
             </React.Fragment>
          );
        })}
      </Stack>

      <ImageGenModal open={modalOpen} onClose={() => setModalOpen(false)} prompt={currentPrompt} onPasteImage={handleGenFinish} />
      <MangaViewer open={viewerOpen} onClose={() => setViewerOpen(false)} project={project} getAssetUrl={getAssetUrl} />

      {/* Image Export Modal (略) */}
      <Dialog open={imgExportOpen} onClose={() => setImgExportOpen(false)} maxWidth="xs" fullWidth>
        <DialogTitle sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <DownloadIcon color="info" /> 画像エクスポート設定
        </DialogTitle>
        <DialogContent dividers>
          <Stack spacing={3} sx={{ mt: 1 }}>
            <Box>
              <FormLabel component="legend" sx={{ mb: 1, fontSize: '0.85rem' }}>アスペクト比</FormLabel>
              <ToggleButtonGroup
                value={exportRatio}
                exclusive
                onChange={(_, v) => v && setExportRatio(v)}
                fullWidth
                size="small"
                color="info"
              >
                <ToggleButton value="9:16"><CropPortraitIcon sx={{ mr: 1 }}/> 9:16 (TikTok)</ToggleButton>
                <ToggleButton value="16:9"><CropLandscapeIcon sx={{ mr: 1 }}/> 16:9 (YouTube)</ToggleButton>
              </ToggleButtonGroup>
            </Box>
            <Divider />
            <FormControl fullWidth>
              <FormLabel component="legend" sx={{ mb: 1, fontSize: '0.85rem' }}>コンテンツ</FormLabel>
              <FormControlLabel
                control={<Switch checked={exportWithText} onChange={e => setExportWithText(e.target.checked)} />}
                label={exportWithText ? "テロップあり" : "画像のみ"}
              />
            </FormControl>
            <Divider />
            <FormControl component="fieldset">
              <FormLabel component="legend" sx={{ mb: 1, fontSize: '0.85rem' }}>出力形式</FormLabel>
              <RadioGroup row value={exportMode} onChange={e => setExportMode(e.target.value as any)}>
                <FormControlLabel value="zip" control={<Radio />} label={<Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}><FolderZipIcon fontSize="small"/> ZIP</Box>} />
                <FormControlLabel value="single" control={<Radio />} label={<Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}><InsertPhotoIcon fontSize="small"/> 表紙のみ</Box>} />
              </RadioGroup>
            </FormControl>
          </Stack>
        </DialogContent>
        <DialogActions sx={{ p: 2 }}>
          <Button onClick={() => setImgExportOpen(false)} color="inherit">キャンセル</Button>
          <Button onClick={handleImageExport} variant="contained" color="info" startIcon={<DownloadIcon />}>
            ダウンロード
          </Button>
        </DialogActions>
      </Dialog>

    </Box>
  );
};

export default StoryEditor;
"""

# 2. src/components/MangaViewer.tsx
# ビューワー動画対応: storyboard全走査、動画再生＋オートページ送り
files_content['src/components/MangaViewer.tsx'] = """import React, { useState, useEffect, useCallback } from 'react';
import {
  Dialog, Box, IconButton, Typography, Fade
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import NavigateNextIcon from '@mui/icons-material/NavigateNext';
import NavigateBeforeIcon from '@mui/icons-material/NavigateBefore';
import MenuBookIcon from '@mui/icons-material/MenuBook';
import type { Project, ImageBlock } from '../types';

interface MangaViewerProps {
  open: boolean;
  onClose: () => void;
  project: Project;
  getAssetUrl: (id: string | null) => string | undefined;
}

const MangaViewer: React.FC<MangaViewerProps> = ({ open, onClose, project, getAssetUrl }) => {
  // -1: Cover, 0...N: StoryBlocks
  const [currentIndex, setCurrentIndex] = useState(-1);

  // Reset on open
  useEffect(() => {
    if (open) setCurrentIndex(-1);
  }, [open]);

  // ★変更: 画像だけでなく全ブロックを対象にする
  const storyBlocks = project.storyboard;

  const totalPages = storyBlocks.length;
  const isCover = currentIndex === -1;
  const currentBlock = !isCover ? storyBlocks[currentIndex] : null;

  // Navigation Logic
  const handleNext = useCallback(() => {
    if (currentIndex < totalPages - 1) setCurrentIndex(prev => prev + 1);
  }, [currentIndex, totalPages]);

  const handlePrev = useCallback(() => {
    if (currentIndex > -1) setCurrentIndex(prev => prev - 1);
  }, [currentIndex]);

  // Keyboard Support
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!open) return;
      if (e.key === 'ArrowRight' || e.key === ' ') handleNext();
      if (e.key === 'ArrowLeft') handlePrev();
      if (e.key === 'Escape') onClose();
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [open, handleNext, handlePrev, onClose]);

  // Content Resolver
  const currentAssetUrl = isCover 
    ? getAssetUrl(project.coverAssetId) 
    : getAssetUrl(currentBlock?.assignedAssetId || null);

  const currentText = isCover 
    ? project.synopsis 
    : (currentBlock?.type === 'image' ? (currentBlock as ImageBlock).dialogue : "");

  return (
    <Dialog
      fullScreen
      open={open}
      onClose={onClose}
      sx={{ '& .MuiDialog-paper': { bgcolor: '#000' } }} // 完全な黒背景
    >
      {/* Close Button */}
      <IconButton 
        onClick={onClose} 
        sx={{ position: 'absolute', top: 16, right: 16, color: 'white', zIndex: 10, bgcolor: 'rgba(255,255,255,0.1)' }}
      >
        <CloseIcon />
      </IconButton>

      {/* Main Content Area */}
      <Box 
        sx={{ 
          width: '100%', height: '100%', display: 'flex', flexDirection: 'column', 
          alignItems: 'center', justifyContent: 'center', p: 2 
        }}
        onClick={handleNext} // Click anywhere to next
      >
        <Fade in={true} key={currentIndex} timeout={400}>
          <Box sx={{ 
            display: 'flex', flexDirection: 'column', alignItems: 'center', 
            maxWidth: '100%', maxHeight: '100%', gap: 2 
          }}>
            
            {/* Image / Video Area */}
            <Box sx={{ position: 'relative', maxHeight: '75vh', maxWidth: '100vw' }}>
              {currentAssetUrl ? (
                currentBlock?.type === 'video' ? (
                   // ★動画ブロックの場合: ループなし、終了時に自動で次へ
                   <video 
                     src={currentAssetUrl} 
                     autoPlay 
                     playsInline 
                     muted={false}
                     onEnded={handleNext} 
                     style={{ maxHeight: '75vh', maxWidth: '100%', boxShadow: '0 0 20px rgba(255,255,255,0.1)' }}
                   />
                ) : (
                   // 静止画ブロックまたは表紙
                   <Box 
                     component="img" 
                     src={currentAssetUrl} 
                     sx={{ maxHeight: '75vh', maxWidth: '100%', objectFit: 'contain', boxShadow: '0 0 20px rgba(255,255,255,0.1)' }}
                   />
                )
              ) : (
                <Box sx={{ 
                  width: '60vh', height: '60vh', bgcolor: '#1e293b', display: 'flex', 
                  alignItems: 'center', justifyContent: 'center', color: '#64748b', flexDirection: 'column'
                }}>
                  <MenuBookIcon sx={{ fontSize: 64, mb: 2, opacity: 0.5 }} />
                  <Typography>No Content</Typography>
                </Box>
              )}
              
              {/* Page Number Badge */}
              <Box sx={{ 
                position: 'absolute', bottom: 10, right: 10, 
                bgcolor: 'rgba(0,0,0,0.7)', color: 'white', px: 1.5, py: 0.5, borderRadius: 1,
                fontSize: '0.8rem', fontFamily: 'monospace'
              }}>
                {isCover ? 'COVER' : (currentBlock?.type === 'image' ? `P.${(currentBlock as ImageBlock).pageNumber}` : 'VIDEO')}
              </Box>
            </Box>

            {/* Text Area (Subtitle Style) */}
            {/* 動画の場合は字幕エリアを隠すか、空でも表示しておくか。ここではテキストがある場合のみ表示する */}
            {(isCover || (currentBlock?.type === 'image' && currentText)) && (
              <Box sx={{ 
                width: '100%', maxWidth: 800, minHeight: 100,
                bgcolor: 'rgba(20, 20, 20, 0.8)', border: '1px solid #333', borderRadius: 2, 
                p: 3, textAlign: 'center', display: 'flex', flexDirection: 'column', justifyContent: 'center'
              }}>
                {isCover && (
                  <Typography variant="h4" color="primary.main" fontWeight="bold" gutterBottom>
                    {project.title}
                  </Typography>
                )}
                <Typography variant="h6" color="white" sx={{ fontStyle: isCover ? 'italic' : 'normal', lineHeight: 1.6 }}>
                  {currentText}
                </Typography>
              </Box>
            )}

          </Box>
        </Fade>
      </Box>

      {/* Navigation Overlay Buttons (Mouse Hover) */}
      <Box sx={{ position: 'fixed', top: '50%', left: 20, transform: 'translateY(-50%)' }}>
        <IconButton onClick={(e) => { e.stopPropagation(); handlePrev(); }} disabled={currentIndex <= -1} sx={{ color: 'white', bgcolor: 'rgba(255,255,255,0.1)', '&:hover': { bgcolor: 'primary.main' } }}>
          <NavigateBeforeIcon fontSize="large" />
        </IconButton>
      </Box>
      <Box sx={{ position: 'fixed', top: '50%', right: 20, transform: 'translateY(-50%)' }}>
        <IconButton onClick={(e) => { e.stopPropagation(); handleNext(); }} disabled={currentIndex >= totalPages - 1} sx={{ color: 'white', bgcolor: 'rgba(255,255,255,0.1)', '&:hover': { bgcolor: 'primary.main' } }}>
          <NavigateNextIcon fontSize="large" />
        </IconButton>
      </Box>

    </Dialog>
  );
};

export default MangaViewer;
"""

# 3. src/utils/projectIO.ts
# エクスポート修正: 動画アセットのIDを収集対象に含める
files_content['src/utils/projectIO.ts'] = """import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import type { Project, Asset, StoryBlock } from '../types';
import type { AppDispatch } from '../app/store';
import { addAsset } from '../features/assets/assetSlice';
import { createOrUpdateProject, setCurrentProject } from '../features/projects/projectSlice';
import { v4 as uuidv4 } from 'uuid';

/**
 * プロジェクトと使用画像をZIPにまとめてエクスポート
 */
export const exportProjectToZip = async (project: Project, assets: Asset[]) => {
  const zip = new JSZip();
  
  // 1. プロジェクトデータをJSONとして追加
  zip.file('project.json', JSON.stringify(project, null, 2));

  // 2. 使用されているアセットIDを収集
  const usedIds = new Set<string>();
  if (project.coverAssetId) usedIds.add(project.coverAssetId);
  project.storyboard.forEach(b => {
    // ★修正: assignedAssetIdがあれば型を問わず収集
    if (b.assignedAssetId) usedIds.add(b.assignedAssetId);
  });

  // 3. 画像ファイルを追加
  const assetsFolder = zip.folder('assets');
  if (assetsFolder) {
    for (const id of usedIds) {
      const asset = assets.find(a => a.id === id);
      if (asset) {
        try {
          // URLからBlobを取得してZIPに追加
          const res = await fetch(asset.url);
          const blob = await res.blob();
          // 拡張子の推定 (簡易的)
          let ext = 'png';
          if (blob.type === 'image/jpeg') ext = 'jpg';
          else if (blob.type === 'image/svg+xml') ext = 'svg';
          else if (blob.type.startsWith('video/')) ext = 'mp4'; // 動画対応
          
          assetsFolder.file(`${id}.${ext}`, blob);
        } catch (e) {
          console.error(`Failed to export asset ${id}`, e);
        }
      }
    }
  }

  // 4. ZIP生成とダウンロード
  const content = await zip.generateAsync({ type: 'blob' });
  saveAs(content, `${project.title}.zip`);
};

/**
 * ZIPファイルからプロジェクトを復元
 */
export const importProjectFromZip = async (file: File, dispatch: AppDispatch) => {
  const zip = await JSZip.loadAsync(file);
  
  // 1. project.json を読む
  const projectFile = zip.file('project.json');
  if (!projectFile) throw new Error('project.json が見つかりません (無効なファイルです)');
  
  const projectJson = await projectFile.async('string');
  const rawProject = JSON.parse(projectJson);
  
  // 2. 画像を復元し、IDのマッピングを作成 (旧ID -> 新ID)
  const idMap = new Map<string, string>();
  const assetsFolder = zip.folder('assets');
  
  if (assetsFolder) {
    // フォルダ内のファイルを走査
    const entries: Array<{ name: string, fileObj: JSZip.JSZipObject }> = [];
    assetsFolder.forEach((relativePath, fileObj) => {
      entries.push({ name: relativePath, fileObj });
    });

    for (const entry of entries) {
      // ファイル名 (oldId.ext) から旧IDを取得
      const oldId = entry.name.split('.')[0];
      const ext = entry.name.split('.').pop()?.toLowerCase();
      
      const blob = await entry.fileObj.async('blob');
      
      // MIMEタイプの推定
      let mimeType = blob.type;
      if (!mimeType) {
        if (ext === 'png') mimeType = 'image/png';
        else if (ext === 'jpg' || ext === 'jpeg') mimeType = 'image/jpeg';
        else if (ext === 'svg') mimeType = 'image/svg+xml';
        else if (ext === 'mp4' || ext === 'webm') mimeType = 'video/mp4';
        else mimeType = 'image/png'; // Default fallback
      }

      // Fileオブジェクト化
      const imageFile = new File([blob], entry.name, { type: mimeType });
      
      // Reduxアクションでアップロード（新規IDが発行される）
      const resultAction = await dispatch(addAsset({ file: imageFile, category: 'material' }));
      
      if (addAsset.fulfilled.match(resultAction)) {
        const newId = resultAction.payload.id;
        idMap.set(oldId, newId);
      }
    }
  }

  // 3. マイグレーション (pages -> storyboard)
  let storyboard: StoryBlock[] = [];
  if (rawProject.storyboard) {
    storyboard = rawProject.storyboard;
  } else if (rawProject.pages) {
    storyboard = rawProject.pages.map((p: any) => ({
      ...p,
      id: uuidv4(),
      type: 'image'
    }));
  }

  // 4. プロジェクトデータのIDを新しいものに書き換え
  const newProject: Project = {
    ...rawProject,
    id: uuidv4(), // プロジェクトIDも一新して「コピー」として扱う
    title: rawProject.title + " (Imported)",
    coverAssetId: rawProject.coverAssetId ? (idMap.get(rawProject.coverAssetId) || null) : null,
    storyboard: storyboard.map(b => {
        // 画像も動画も assignedAssetId を持っているので共通で書き換え
        return {
          ...b,
          assignedAssetId: b.assignedAssetId ? (idMap.get(b.assignedAssetId) || null) : null
        };
    }),
    createdAt: Date.now(),
    updatedAt: Date.now()
  };

  // レガシーフィールドの削除
  if ('pages' in newProject) {
    delete (newProject as any).pages;
  }

  // 5. 保存して開く
  await dispatch(createOrUpdateProject(newProject));
  dispatch(setCurrentProject(newProject));
  
  return newProject;
};
"""

for filepath, content in files_content.items():
    dirpath = os.path.dirname(filepath)
    if dirpath and not os.path.exists(dirpath):
        os.makedirs(dirpath)
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)
        print(f"Updated: {filepath}")

print("\\nTicket #3 Implementation complete.")