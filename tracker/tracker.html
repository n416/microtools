<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>pt予測機 v2</title>
  <style>
    body {
      font-family: sans-serif;
      line-height: 1.6;
      padding: 15px;
      /* Reduced padding */
      background-color: #f8f9fa;
      /* Lighter gray */
      margin: 0;
    }

    .container {
      max-width: 1200px;
      /* Wider max-width for multi-column */
      margin: auto;
    }

    #control-panel {
      background: #fff;
      padding: 10px 15px;
      margin-bottom: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      /* Allow wrapping on small screens */
      gap: 10px;
    }

    #trackers-container {
      display: flex;
      flex-wrap: wrap;
      /* Enable wrapping */
      gap: 15px;
      /* Space between trackers */
      margin-bottom: 20px;
    }

    .tracker {
      border: 1px solid #dee2e6;
      /* Lighter border */
      padding: 15px;
      border-radius: 8px;
      /* More rounded */
      background-color: #fff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      position: relative;
      /* Default to full width, media queries will adjust */
      flex: 1 1 100%;
      min-width: 280px;
      /* Minimum width before wrapping */
      box-sizing: border-box;
      /* Include padding/border in width */
      display: flex;
      /* Use flexbox for internal layout */
      flex-direction: column;
      /* Stack elements vertically */
    }

    /* --- Media Queries for Layout --- */
    /* Tablet and up (2 columns) */
    @media (min-width: 600px) {
      .tracker {
        flex-basis: calc(50% - 8px);
        /* 2 columns, adjust for gap */
      }
    }

    /* Desktop (3 columns) */
    @media (min-width: 992px) {
      .tracker {
        flex-basis: calc(33.333% - 10px);
        /* 3 columns, adjust for gap */
      }
    }

    .tracker h3 {
      margin: -15px -15px 10px -15px;
      /* Extend to edges */
      padding: 10px 15px;
      border-bottom: 1px solid #eee;
      background-color: #f8f9fa;
      /* Slight background for header */
      border-radius: 8px 8px 0 0;
      /* Rounded top corners */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .tracker-title {
      border: none;
      font-size: 1.1em;
      font-weight: bold;
      width: calc(100% - 30px);
      /* Adjust for remove button */
      background: transparent;
      padding: 2px 5px;
      margin: -2px -5px;
      /* Offset padding */
    }

    .tracker-title:focus {
      outline: none;
      background-color: rgba(0, 123, 255, 0.1);
    }

    .input-group {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 5px;
      /* Reduced gap */
    }

    .input-group label {
      flex-shrink: 0;
      width: 85px;
      /* Slightly wider label */
      font-size: 0.95em;
      color: #495057;
      /* Darker text */
    }

    .input-group input[type="number"],
    .input-group button {
      padding: 7px 10px;
      /* Slightly adjusted padding */
      border: 1px solid #ced4da;
      /* Standard border color */
      border-radius: 4px;
      font-size: 0.95em;
    }

    .input-group input[type="number"] {
      flex-grow: 1;
      min-width: 60px;
      /* Smaller min-width */
    }

    .input-group button {
      cursor: pointer;
      background-color: #007bff;
      color: white;
      border: none;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
      /* Prevent button shrinking */
    }

    .input-group button:hover {
      background-color: #0056b3;
    }

    .results {
      margin-top: 5px;
      margin-bottom: 10px;
      font-size: 0.9em;
      color: #6c757d;
      /* Grayish text */
    }

    .results span {
      /* Rate display blocks */
      display: inline-block;
      min-width: 100px;
      /* Reduced min-width */
      font-weight: bold;
      margin-right: 10px;
      background-color: #e9ecef;
      padding: 4px 8px;
      border-radius: 4px;
      margin-bottom: 5px;
      color: #212529;
      /* Darker text for rates */
    }

    .history {
      font-size: 0.9em;
      color: #555;
      margin-top: auto;
      /* Push history to bottom */
      padding-top: 10px;
      border-top: 1px dashed #eee;
      max-height: 120px;
      /* Increased max height */
      overflow-y: auto;
      background-color: #fdfdfd;
      /* Very light background */
      border-radius: 0 0 8px 8px;
      /* Rounded bottom */
      margin: 0 -15px -15px -15px;
      /* Extend to edges */
      padding: 10px 15px;
    }

    .history-entry {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
      padding: 2px 0;
    }

    .history-entry:hover {
      background-color: #f1f1f1;
      /* Highlight on hover */
    }

    .delete-history {
      background: none;
      border: none;
      color: #dc3545;
      cursor: pointer;
      font-size: 1.1em;
      padding: 0 5px;
      line-height: 1;
      opacity: 0.5;
      /* Hide slightly */
      transition: opacity 0.2s;
    }

    .history-entry:hover .delete-history {
      opacity: 1;
      /* Show on hover */
    }

    .remove-tracker {
      background-color: #6c757d;
      /* Gray remove button */
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
      line-height: 1;
      transition: background-color 0.2s;
    }

    .remove-tracker:hover {
      background-color: #5a6268;
    }

    .main-button {
      padding: 8px 15px;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.95em;
      transition: background-color 0.2s;
    }

    .main-button:hover {
      background-color: #218838;
    }

    #share-button {
      background-color: #17a2b8;
      /* Info color */
    }

    #share-button:hover {
      background-color: #138496;
    }

    .error,
    .info-message {
      color: #dc3545;
      font-size: 0.9em;
      margin-top: 5px;
      min-height: 1.2em;
      /* Reserve space */
    }

    .info-message {
      color: #007bff;
      /* Blue for info */
    }

    .time-remaining {
      margin-top: 5px;
      font-weight: bold;
      color: #17a2b8;
      /* Teal color */
      font-size: 0.95em;
      min-height: 1.2em;
    }

    .latex-num {
      text-align: center;
      /* font-style: italic; */
    }

    .unit {
      font-size: 0.9em;
      color: #666;
      margin-left: 3px;
      /* Space before unit */
    }

    /* --- Tooltip for Share Button --- */
    [data-tooltip] {
      position: relative;
      cursor: pointer;
    }

    [data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 110%;
      /* Position above the button */
      left: 50%;
      transform: translateX(-50%);
      background-color: #343a40;
      /* Dark background */
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.85em;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s, visibility 0.2s;
      z-index: 10;
    }

    [data-tooltip]:hover::after {
      opacity: 1;
      visibility: visible;
    }
  </style>
</head>

<body>

  <div class="container">
    <div id="control-panel">
      <h1>pt予測機</h1>
      <div>
        <button id="add-tracker" class="main-button">トラッカーを追加</button>
        <button id="share-button" class="main-button" data-tooltip="現在の全トラッカー情報を共有URLとしてコピーします">共有URLコピー</button>
      </div>
    </div>

    <div id="trackers-container">
    </div>
  </div>

  <script>
    const trackersContainer = document.getElementById('trackers-container');
    const addTrackerButton = document.getElementById('add-tracker');
    const shareButton = document.getElementById('share-button');
    const LOCAL_STORAGE_KEY = 'trackerData_v2'; // Use a versioned key
    let trackersData = {}; // Store data like { trackerId: { title: '...', history: [{count, time(ms)}], target: null } }
    let nextTrackerId = 0; // Keep track of the next ID to assign

    // --- Utility Functions ---
    function formatNumber(num) {
      return Number.isInteger(num) ? num : num.toFixed(2);
    }

    function formatTime(timestamp) {
      return new Date(timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function getTrackerElement(trackerId) {
      return document.getElementById(`tracker-${trackerId}`);
    }

    function updateElementText(element, text) {
      if (element) element.textContent = text;
    }

    function updateElementHTML(element, html) {
      if (element) element.innerHTML = html;
    }

    // --- Core Logic Functions ---
    function calculateRates(trackerId) {
      const data = trackersData[trackerId];
      if (!data) return;

      const trackerElement = getTrackerElement(trackerId);
      if (!trackerElement) return;

      const ratePerMinElement = trackerElement.querySelector('.rate-per-min');
      const ratePerHourElement = trackerElement.querySelector('.rate-per-hour');
      const timeRemainingElement = trackerElement.querySelector('.time-remaining');
      const historyElement = trackerElement.querySelector('.history');
      const errorElement = trackerElement.querySelector('.error-message');

      // Reset display elements
      updateElementText(errorElement, '');
      updateElementHTML(ratePerMinElement, `<span class="latex-num">---</span><span class="unit">pt/分</span>`);
      updateElementHTML(ratePerHourElement, `<span class="latex-num">---</span><span class="unit">pt/時間</span>`);
      updateElementText(timeRemainingElement, '');

      // Sort history by time just in case (important after deletions)
      data.history.sort((a, b) => a.time - b.time);

      // Update history display with delete buttons
      historyElement.innerHTML = '履歴:<br>' + data.history.map(entry => `
            <div class="history-entry" data-timestamp="${entry.time}">
                <span>${formatTime(entry.time)}: <span class="latex-num">${entry.count}</span> pt</span>
                <button class="delete-history" title="この履歴を削除">×</button>
            </div>`).reverse().join('');

      if (data.history.length < 2) {
        updateElementText(errorElement, data.history.length === 1 ? 'レート計算には履歴が2件以上必要です' : '');
        return;
      }

      const latest = data.history[data.history.length - 1];
      const previous = data.history[data.history.length - 2];

      const countDiff = latest.count - previous.count;
      const timeDiffMs = latest.time - previous.time;
      const timeDiffMinutes = timeDiffMs / (1000 * 60);

      if (timeDiffMinutes <= (1 / 600)) { // Minimum 0.1 seconds to avoid weird results
        updateElementText(errorElement, 'エラー: 計測間隔が短すぎます。');
        return;
      }
      if (countDiff < 0) {
        updateElementText(errorElement, '注意: ポイント数が減少しました。');
      }

      const ratePerMinute = countDiff / timeDiffMinutes;
      const ratePerHour = ratePerMinute * 60;

      updateElementHTML(ratePerMinElement, `<span class="latex-num">${formatNumber(ratePerMinute)}</span><span class="unit">pt/分</span>`);
      updateElementHTML(ratePerHourElement, `<span class="latex-num">${formatNumber(ratePerHour)}</span><span class="unit">pt/時間</span>`);

      if (data.target !== null && typeof data.target === 'number' && data.target >= 0) {
        if (data.target <= latest.count) {
          updateElementText(timeRemainingElement, `目標(${data.target}pt)達成済み！`);
        } else if (ratePerHour > 0) {
          const remainingCount = data.target - latest.count;
          const remainingHours = remainingCount / ratePerHour;
          const totalMinutes = Math.ceil(remainingHours * 60);

          const hours = Math.floor(totalMinutes / 60);
          const minutes = totalMinutes % 60;
          updateElementText(timeRemainingElement, `目標(${data.target}pt)まで: あと 約 ${hours} 時間 ${minutes} 分`);
        } else {
          updateElementText(timeRemainingElement, `目標(${data.target}pt)まで: (ポイントペース低下中または停止中)`);
        }
      } else {
        updateElementText(timeRemainingElement, ''); // Clear if target is invalid or not set
      }
    }

    function recordData(trackerId) {
      const data = trackersData[trackerId];
      if (!data) return;
      const trackerElement = getTrackerElement(trackerId);
      if (!trackerElement) return;

      const countInput = trackerElement.querySelector('.count-input');
      const errorElement = trackerElement.querySelector('.error-message');
      const count = parseInt(countInput.value, 10);

      updateElementText(errorElement, '');

      if (isNaN(count) || count < 0) {
        updateElementText(errorElement, '有効な数値を入力してください。');
        return;
      }

      // Add new entry with current timestamp (milliseconds)
      data.history.push({ count: count, time: Date.now() });
      countInput.value = '';
      calculateRates(trackerId);
      saveDataToLocalStorage();
    }

    function updateTarget(trackerId) {
      const data = trackersData[trackerId];
      if (!data) return;
      const trackerElement = getTrackerElement(trackerId);
      if (!trackerElement) return;

      const targetInput = trackerElement.querySelector('.target-input');
      const targetValue = targetInput.value;

      if (targetValue === '' || targetValue === null) {
        data.target = null;
      } else {
        const target = parseInt(targetValue, 10);
        if (!isNaN(target) && target >= 0) {
          data.target = target;
        } else {
          data.target = null;
          targetInput.value = ''; // Clear invalid input
        }
      }
      calculateRates(trackerId);
      saveDataToLocalStorage();
    }

    function updateTitle(trackerId, newTitle) {
      const data = trackersData[trackerId];
      if (data) {
        data.title = newTitle.trim();
        saveDataToLocalStorage();
      }
    }

    function deleteHistoryEntry(trackerId, timestamp) {
      const data = trackersData[trackerId];
      if (!data) return;

      const timeNum = parseInt(timestamp, 10); // Ensure timestamp is a number
      data.history = data.history.filter(entry => entry.time !== timeNum);

      calculateRates(trackerId);
      saveDataToLocalStorage();
    }

    function removeTracker(trackerId) {
      const trackerElement = getTrackerElement(trackerId);
      if (trackerElement) {
        trackerElement.remove();
      }
      delete trackersData[trackerId];
      saveDataToLocalStorage();
      updateRemoveButtonsVisibility(); // Update visibility after removal
    }

    // Show/hide remove buttons based on the number of trackers
    function updateRemoveButtonsVisibility() {
      const remainingTrackers = trackersContainer.querySelectorAll('.tracker');
      const visible = remainingTrackers.length > 1;
      remainingTrackers.forEach(tracker => {
        const removeButton = tracker.querySelector('.remove-tracker');
        if (removeButton) {
          removeButton.style.display = visible ? 'inline-block' : 'none';
        }
      });
    }

    function addTracker(initialData = null) {
      const trackerId = nextTrackerId++; // Use and increment the global counter
      const initialTitle = initialData?.title || `トラッカー ${trackerId + 1}`;
      const initialHistory = initialData?.history || []; // Expecting {count, time} format
      const initialTarget = initialData?.target ?? null; // Use null coalescing

      trackersData[trackerId] = {
        title: initialTitle,
        history: initialHistory,
        target: initialTarget
      };

      const trackerDiv = document.createElement('div');
      trackerDiv.classList.add('tracker');
      trackerDiv.id = `tracker-${trackerId}`;

      trackerDiv.innerHTML = `
            <h3>
                <input type="text" value="${initialTitle.replace(/"/g, '&quot;')}" class="tracker-title" placeholder="名前 (例: 自分)" data-tracker-id="${trackerId}">
                <button class="remove-tracker" title="このトラッカーを削除" data-tracker-id="${trackerId}">×</button>
            </h3>
            <div class="input-group">
                <label for="count-${trackerId}">現在:</label>
                <input type="number" id="count-${trackerId}" class="count-input" placeholder="ポイント数" min="0" step="1">
                <button class="record-button" data-tracker-id="${trackerId}">記録</button>
            </div>
             <div class="input-group">
                <label for="target-${trackerId}">目標</label>
                <input type="number" id="target-${trackerId}" class="target-input" placeholder="任意" min="0" step="1" value="${initialTarget !== null ? initialTarget : ''}">
            </div>
            <div class="results">
                レート:
                <span class="rate-per-min"><span class="latex-num">---</span><span class="unit">pt/分</span></span>
                <span class="rate-per-hour"><span class="latex-num">---</span><span class="unit">pt/時間</span></span>
            </div>
            <div class="time-remaining"></div>
            <div class="error-message error"></div>
            <div class="info-message"></div>
            <div class="history">履歴:<br></div>
        `;

      trackersContainer.appendChild(trackerDiv);

      // --- Add event listeners using event delegation where possible ---
      const trackerTitleInput = trackerDiv.querySelector('.tracker-title');
      const countInput = trackerDiv.querySelector('.count-input');
      const recordButton = trackerDiv.querySelector('.record-button');
      const targetInput = trackerDiv.querySelector('.target-input');
      const removeButton = trackerDiv.querySelector('.remove-tracker');
      const historyDiv = trackerDiv.querySelector('.history');

      trackerTitleInput.addEventListener('change', (e) => updateTitle(trackerId, e.target.value));
      trackerTitleInput.addEventListener('input', (e) => updateTitle(trackerId, e.target.value)); // Save on input too

      recordButton.addEventListener('click', () => recordData(trackerId));
      countInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') recordData(trackerId); });

      targetInput.addEventListener('input', () => updateTarget(trackerId));
      targetInput.addEventListener('change', () => updateTarget(trackerId)); // Ensure saving on blur

      removeButton.addEventListener('click', () => removeTracker(trackerId));

      // Event delegation for history delete buttons
      historyDiv.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-history')) {
          const entryDiv = e.target.closest('.history-entry');
          if (entryDiv) {
            const timestamp = entryDiv.getAttribute('data-timestamp');
            deleteHistoryEntry(trackerId, timestamp);
          }
        }
      });

      // Initial calculation and update remove button visibility
      calculateRates(trackerId); // Calculate rates for the new tracker
      updateRemoveButtonsVisibility();
      if (initialData) {
        saveDataToLocalStorage(); // Save if added from loaded data
      }
    }

    // --- LocalStorage Functions ---
    function saveDataToLocalStorage() {
      // Update titles from input fields before saving
      Object.keys(trackersData).forEach(id => {
        const trackerElement = getTrackerElement(id);
        if (trackerElement) {
          const titleInput = trackerElement.querySelector('.tracker-title');
          if (titleInput && trackersData[id]) { // Check if data still exists
            trackersData[id].title = titleInput.value.trim();
          }
        }
      });

      const dataToSave = {
        trackers: trackersData,
        nextId: nextTrackerId // Save the next ID counter
      };
      try {
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
        console.log("Data saved to localStorage.");
      } catch (e) {
        console.error("Failed to save data to localStorage:", e);
        // Optionally inform the user
      }
    }

    function loadDataFromLocalStorage() {
      console.log("Attempting to load data from localStorage...");
      const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
      if (savedData) {
        try {
          const parsedData = JSON.parse(savedData);
          // Basic validation
          if (parsedData && typeof parsedData.trackers === 'object' && typeof parsedData.nextId === 'number') {
            // Clear existing UI before loading
            trackersContainer.innerHTML = '';
            trackersData = {}; // Reset in-memory data

            // Load trackers
            Object.keys(parsedData.trackers).forEach(id => {
              const tracker = parsedData.trackers[id];
              // Make sure history entries have numbers for time
              if (tracker.history && Array.isArray(tracker.history)) {
                tracker.history = tracker.history.map(entry => ({
                  count: entry.count,
                  time: Number(entry.time) // Ensure time is number
                }));
              }
              addTracker(tracker); // Add tracker with loaded data
            });
            nextTrackerId = parsedData.nextId; // Restore the next ID counter
            console.log("Data loaded successfully.");
            return true; // Indicate data was loaded
          } else {
            console.warn("Loaded data format is incorrect. Using default.");
            localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove corrupted data
          }
        } catch (e) {
          console.error("Failed to parse data from localStorage:", e);
          localStorage.removeItem(LOCAL_STORAGE_KEY); // Remove potentially corrupted data
        }
      } else {
        console.log("No data found in localStorage.");
      }
      return false; // Indicate no data was loaded
    }

    function generateShareUrl() {
      // Ensure current titles are captured before generating URL
      Object.keys(trackersData).forEach(id => {
        const trackerElement = getTrackerElement(id);
        if (trackerElement) {
          const titleInput = trackerElement.querySelector('.tracker-title');
          if (titleInput && trackersData[id]) {
            trackersData[id].title = titleInput.value.trim();
          }
        }
      });

      const dataToShare = {
        trackers: trackersData,
        // No need to share nextId for import purposes
      };

      try {
        const jsonString = JSON.stringify(dataToShare);
        // *** CHANGE HERE: Directly use encodeURIComponent on the JSON string ***
        const encodedData = encodeURIComponent(jsonString);
        const url = `${window.location.origin}${window.location.pathname}?data=${encodedData}`;
        return url;
      } catch (e) {
        console.error("Failed to generate share URL:", e);
        return null;
      }
    }

    function handleShareUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        const encodedData = urlParams.get('data'); // This is percent-encoded JSON

        if (encodedData) {
            console.log("Shared data detected in URL.");
            let jsonString;
            let parsedData;
            try {
                // *** CHANGE HERE: Directly use decodeURIComponent ***
                jsonString = decodeURIComponent(encodedData);
                // Now parse the decoded JSON string
                parsedData = JSON.parse(jsonString);

                 // Basic validation of shared data structure
                 if (!parsedData || typeof parsedData.trackers !== 'object') {
                     throw new Error("Invalid shared data structure.");
                 }

            } catch (e) {
                console.error("Failed to decode or parse shared data:", e);
                // Add specific check for URIError during decode
                if (e instanceof URIError) {
                     alert("共有データの読み込みに失敗しました。URLの形式が正しくない可能性があります。");
                } else {
                     alert("共有データの読み込みに失敗しました。データが破損しているか、形式が違う可能性があります。");
                }
                // Clean URL and proceed with normal loading
                history.replaceState(null, '', window.location.pathname);
                return false; // Indicate shared data was not processed
            }

            // --- Confirmation and loading logic remains the same ---
            const proceed = confirm("共有されたデータが見つかりました。\n現在のデータを上書きして読み込みますか？");

            if (proceed) {
                console.log("User confirmed overwrite.");
                // Clear current state (localStorage and UI)
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                trackersContainer.innerHTML = '';
                trackersData = {};
                nextTrackerId = 0; // Reset ID counter

                // Load data from shared parameter
                Object.keys(parsedData.trackers).forEach(id => {
                     const tracker = parsedData.trackers[id];
                      // Ensure history times are numbers
                      if (tracker.history && Array.isArray(tracker.history)) {
                           tracker.history = tracker.history.map(entry => ({
                               count: entry.count,
                               time: Number(entry.time)
                           }));
                      }
                     addTracker(tracker); // Add tracker with shared data
                 });
                 // Find the highest existing ID from loaded data to safely set nextTrackerId
                 const maxId = Object.keys(trackersData).reduce((max, id) => Math.max(max, parseInt(id, 10)), -1);
                 nextTrackerId = maxId + 1;

                saveDataToLocalStorage(); // Save the imported data
                console.log("Shared data loaded and saved.");

            } else {
                console.log("User cancelled overwrite.");
                // Do nothing with the shared data, proceed to load local data
            }

            // Clean the URL regardless of user choice
            history.replaceState(null, '', window.location.pathname);
            return true; // Indicate shared data was processed (or ignored after prompt)
        }
        return false; // Indicate no shared data found in URL
    }

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM Loaded.");

      // Handle incoming share URL first
      const sharedDataHandled = handleShareUrl();

      // If shared data wasn't handled (or user cancelled), load from localStorage
      if (!sharedDataHandled) {
        const loaded = loadDataFromLocalStorage();
        // If nothing was loaded from storage (first visit or cleared), add one default tracker
        if (!loaded && Object.keys(trackersData).length === 0) {
          console.log("Adding default tracker.");
          addTracker();
          updateRemoveButtonsVisibility(); // Ensure remove button is hidden for the single tracker
        }
      }

      // Event listener for the global add button
      addTrackerButton.addEventListener('click', () => {
        addTracker();
        saveDataToLocalStorage(); // Save state after adding
      });

      // Event listener for the share button
      shareButton.addEventListener('click', () => {
        const url = generateShareUrl();
        if (url) {
          navigator.clipboard.writeText(url).then(() => {
            // Simple feedback
            const originalTooltip = shareButton.getAttribute('data-tooltip');
            shareButton.setAttribute('data-tooltip', 'コピーしました!');
            setTimeout(() => {
              shareButton.setAttribute('data-tooltip', originalTooltip);
            }, 1500);
            console.log("Share URL copied to clipboard:", url);
          }).catch(err => {
            console.error('Failed to copy URL: ', err);
            alert('クリップボードへのコピーに失敗しました。');
          });
        } else {
          alert('共有URLの生成に失敗しました。');
        }
      });
    });

  </script>

</body>

</html>