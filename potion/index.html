<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ポーション枯渇予測</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 20px;
      background-color: #f0f2f5;
      color: #333;
      line-height: 1.6;
    }

    .container {
      position: relative;
      background-color: #fff;
      padding: 25px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      max-width: 800px;
      margin: 0 auto;
    }

    h1.app-title {
      /* Changed from h1 to h1.app-title for specificity */
      position: absolute;
      right: 20px;
      top: 20px;
      z-index: 1;
      color: #ddd;
      text-align: right;
      margin: 0;
    }

    h2 {
      color: #1a73e8;
      margin-top: 30px;
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 10px;
    }

    #inputSectionTitle {
      /* Added for dynamic hunting ground name */
      /* uses h2 styles */
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #5f6368;
    }

    input[type="number"],
    input[type="text"],
    /* Added for hunting ground input */
    button,
    select {
      /* Added for hunting ground select */
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 6px;
      border: 1px solid #dadce0;
      font-size: 16px;
      box-sizing: border-box;
    }

    input[type="number"],
    input[type="text"] {
      max-width: 100%;
    }

    button.small-btn {
      padding: 8px;
      font-size: 13px;
      margin-left: 5px;
    }


    button {
      background-color: #1a73e8;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease;
      border: none;
    }

    .hg-modal-button {
      margin-bottom: 0;
      background-color: #aaa;
    }

    @media (max-width: 768px) {
      h1.app-title {
        display: none;
      }

      input[type="number"],
      input[type="text"],
      button.record-button,
      button.hg-modal-button {
        /* Added for hunting ground modal button */
        width: 100%;
        box-sizing: border-box;
      }
    }


    button:hover {
      background-color: #1558b0;
    }

    button.danger {
      background-color: #d93025;
    }

    button.danger:hover {
      background-color: #a50e04;
    }

    #logArea {
      margin-top: 0;
      padding: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background-color: #f8f9fa;
    }

    #logListLatest,
    #logListOlder {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }

    #logListLatest li,
    #logListOlder li {
      padding: 8px 10px;
      border-bottom: 1px dotted #e0e0e0;
      font-size: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #logListLatest li:last-child,
    #logListOlder li:last-child {
      border-bottom: none;
    }

    .log-text {
      flex-grow: 1;
    }

    .delete-log-btn {
      background-color: #ff4d4f;
      color: white;
      border: none;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      margin-left: 10px;
      transition: background-color 0.2s ease;
    }

    .delete-log-btn:hover {
      background-color: #d9363e;
    }

    /* MODIFIED: Prediction Area Structure */
    #predictionMessageArea {
      /* Renamed from predictionArea */
      margin-top: 0px;
      padding: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background-color: #f8f9fa;
      min-height: 50px;
      /* Ensure it has some height even when empty */
    }

    #predictionMessageArea p {
      font-size: 16px;
      color: #3c4043;
      line-height: 1.8;
      margin: 0;
      /* Remove default margin for p inside this div */
    }

    #predictionMessageArea strong {
      color: #1a73e8;
    }

    p.consumption-rate {
      /* Style for consumption rate - now outside predictionMessageArea */
      font-size: 0.9em;
      color: #5f6368;
      padding: 5px 15px;
      /* Give it some padding if needed */
      margin-top: 5px;
      background-color: #f8f9fa;
      /* Match style if desired */
      border: 1px solid #e0e0e0;
      border-radius: 6px;
    }

    /* END MODIFIED */


    .chart-container {
      margin-top: 25px;
      position: relative;
      height: 45vh;
      width: 100%;
    }

    #olderLogsAccordion {
      margin-top: 15px;
    }

    #olderLogsAccordion summary {
      cursor: pointer;
      padding: 10px 15px;
      background-color: #f0f2f5;
      border: 1px solid #dadce0;
      border-radius: 6px;
      font-weight: bold;
      color: #5f6368;
      transition: background-color 0.2s ease;
      outline: none;
    }

    #olderLogsAccordion summary:hover {
      background-color: #e8eaed;
    }

    #olderLogsAccordion[open] summary {
      background-color: #e8eaed;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    #olderLogsAccordion #logListOlder {
      border: 1px solid #dadce0;
      border-top: none;
      border-radius: 0 0 6px 6px;
      padding: 0;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.4);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      border-radius: 10px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .modal-close-btn {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
    }

    .modal-close-btn:hover,
    .modal-close-btn:focus {
      color: black;
      text-decoration: none;
      cursor: pointer;
    }

    .modal h3 {
      margin-top: 0;
      color: #1a73e8;
    }

    #huntingGroundList {
      list-style-type: none;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 4px;
      margin-bottom: 15px;
    }

    #huntingGroundList li {
      padding: 10px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    #huntingGroundList li:last-child {
      border-bottom: none;
    }

    #huntingGroundList li:hover {
      background-color: #f0f2f5;
    }

    #huntingGroundList li .hg-consumption-rate {
      font-size: 0.8em;
      color: #5f6368;
      margin-left: 10px;
    }

    .hg-actions {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
    }

    .hg-actions button {
      margin-top: 10px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/date-fns@3.6.0/cdn.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
</head>

<body>
  <div class="container">
    <h1 class="app-title">ポーション枯渇予測</h1>

    <button onclick="openHuntingGroundModal()" class="hg-modal-button" style="width: auto;">狩り場設定</button>

    <h2 id="inputSectionTitle">入力</h2>
    <div>
      <label for="potionQuantity">現在の数量を入力してください</label>
      <input type="number" id="potionQuantity" name="potionQuantity" min="0" placeholder="例: 100">
      <button class="record-button" onclick="addRecord()">記録する</button>
    </div>

    <div id="logArea">
      <ul id="logListLatest"></ul>
      <details id="olderLogsAccordion" style="display: none;">
        <summary>過去の記録を見る</summary>
        <ul id="logListOlder"></ul>
      </details>
      <p id="noLogsMessage" style="display: none; text-align: center; padding: 10px;">まだ記録がありません。</p>
    </div>

    <h2>予測</h2>
    <div id="predictionMessageArea">
      <p>まだ予測できません。最低2つの記録が必要です。</p>
    </div>
    <p class="consumption-rate" id="consumptionRateDisplay"></p>
    <div class="chart-container">
      <canvas id="potionChart"></canvas>
    </div>
    <button onclick="clearDataForCurrentHuntingGround()" class="danger" style="margin-top: 20px; width: 100%;" id="clearDataButton">現在の狩り場の入力履歴削除</button>
  </div>

  <div id="huntingGroundModal" class="modal">
    <div class="modal-content">
      <span class="modal-close-btn" onclick="closeHuntingGroundModal()">&times;</span>
      <h3>狩り場設定</h3>

      <p>現在の設定: <strong id="currentHuntingGroundDisplay">未設定</strong></p>

      <div>
        <label for="newHuntingGroundName">新しい狩り場を追加:</label>
        <input type="text" id="newHuntingGroundName" placeholder="狩り場名を入力">
        <button onclick="addHuntingGroundHandler()" class="small-btn">追加</button>
      </div>

      <h4>狩り場を選択:</h4>
      <ul id="huntingGroundList">
      </ul>
      <p id="noHuntingGroundsMessage" style="display: none; text-align: center;">「未設定」以外の狩り場はありません。</p>

      <div class="hg-actions">
        <button onclick="clearAllUserHuntingGrounds()" class="danger">「未設定」以外の全狩り場を削除</button>
      </div>
    </div>
  </div>

  <script>
    const DB_NAME = 'PotionTrackerDB_v2';
    const POTION_LOG_STORE_NAME = 'PotionLogStore';
    const HUNTING_GROUND_STORE_NAME = 'HuntingGroundStore';
    const LOCALSTORAGE_LAST_QUANTITY_KEY = 'lastPotionQuantity_v2';
    const LOCALSTORAGE_CURRENT_HG_ID_KEY = 'currentHuntingGroundId_v2';

    const UNSET_HUNTING_GROUND_ID = 0;
    const UNSET_HUNTING_GROUND_NAME = '未設定';

    let db;
    let chartInstance;
    let currentHuntingGroundId = UNSET_HUNTING_GROUND_ID;

    function formatDateTimeSmart(timestamp) {
      if (timestamp === null || timestamp === undefined) return "";
      const dateObj = new Date(timestamp);
      const now = new Date();
      const timeFormatOptions = { hour: '2-digit', minute: '2-digit' };
      if (
        dateObj.getFullYear() === now.getFullYear() &&
        dateObj.getMonth() === now.getMonth() &&
        dateObj.getDate() === now.getDate()
      ) {
        return dateObj.toLocaleTimeString('ja-JP', timeFormatOptions);
      } else {
        const dateFormatOptions = { month: 'numeric', day: 'numeric' };
        return `${dateObj.toLocaleDateString('ja-JP', dateFormatOptions)} ${dateObj.toLocaleTimeString('ja-JP', timeFormatOptions)}`;
      }
    }

    async function initDB() {
      if (!db) {
        db = await idb.openDB(DB_NAME, 2, {
          upgrade(db, oldVersion, newVersion, transaction) {
            if (!db.objectStoreNames.contains(POTION_LOG_STORE_NAME)) {
              const store = db.createObjectStore(POTION_LOG_STORE_NAME, { keyPath: 'id', autoIncrement: true });
              store.createIndex('huntingGroundId_timestamp', ['huntingGroundId', 'timestamp']);
            } else if (oldVersion < 2) {
              const store = transaction.objectStore(POTION_LOG_STORE_NAME);
              if (!store.indexNames.contains('huntingGroundId_timestamp')) {
                store.createIndex('huntingGroundId_timestamp', ['huntingGroundId', 'timestamp']);
              }
            }

            if (!db.objectStoreNames.contains(HUNTING_GROUND_STORE_NAME)) {
              const hgStore = db.createObjectStore(HUNTING_GROUND_STORE_NAME, { keyPath: 'id', autoIncrement: true });
              hgStore.createIndex('name', 'name', { unique: true });
            }
          },
        });
        await ensureUnsetHuntingGroundExists();
      }
    }

    async function ensureUnsetHuntingGroundExists() {
      const tx = db.transaction(HUNTING_GROUND_STORE_NAME, 'readwrite');
      const store = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      let unsetHG = await store.get(UNSET_HUNTING_GROUND_ID);
      if (!unsetHG) {
        try {
          const existingByName = await store.index('name').get(UNSET_HUNTING_GROUND_NAME);
          if (!existingByName) {
            // Try to add with ID 0. If this specific ID causes issues with autoIncrement,
            // this part might need adjustment based on how idb library handles forced IDs
            // on auto-incrementing stores or if a non-autoIncrement key is used for this special entry.
            // Assuming for now that if ID 0 is available (e.g. store is empty), it can be set.
            // A more robust way is to add it and if the ID isn't 0, handle that discrepancy,
            // or ensure the "Unset" one is always found by name and its dynamic ID is used.
            // For simplicity, we aim for ID 0.
            await store.put({ id: UNSET_HUNTING_GROUND_ID, name: UNSET_HUNTING_GROUND_NAME, lastCalculatedConsumptionRate: null });
          } else if (existingByName.id !== UNSET_HUNTING_GROUND_ID) {
            // If "未設定" exists but with different ID, update our reference or log warning.
            // This scenario indicates a potential issue with how UNSET_HUNTING_GROUND_ID is managed.
            console.warn(`'${UNSET_HUNTING_GROUND_NAME}' found with ID ${existingByName.id} instead of ${UNSET_HUNTING_GROUND_ID}.`);
          }
        } catch (e) {
          console.warn("Could not ensure 'Unset' hunting ground with specific ID 0. Will rely on name.", e);
          const byName = await store.index('name').get(UNSET_HUNTING_GROUND_NAME);
          if (!byName) {
            // Add without specifying ID, let autoIncrement handle it, then find its ID.
            // This is safer if forcing ID 0 is problematic.
            const generatedId = await store.add({ name: UNSET_HUNTING_GROUND_NAME, lastCalculatedConsumptionRate: null });
            // UNSET_HUNTING_GROUND_ID would ideally be updated to this generatedId if it's not 0.
            // This complicates things, so the ideal is that ID 0 is settable or reserved.
          }
        }
      }
      await tx.done;

      const storedHgId = localStorage.getItem(LOCALSTORAGE_CURRENT_HG_ID_KEY);
      if (storedHgId !== null) {
        currentHuntingGroundId = parseInt(storedHgId, 10);
        const hg = await getHuntingGroundById(currentHuntingGroundId);
        if (!hg) {
          currentHuntingGroundId = UNSET_HUNTING_GROUND_ID;
          localStorage.setItem(LOCALSTORAGE_CURRENT_HG_ID_KEY, currentHuntingGroundId.toString());
        }
      } else {
        const unsetRecord = await getHuntingGroundByName(UNSET_HUNTING_GROUND_NAME);
        if (unsetRecord) {
          currentHuntingGroundId = unsetRecord.id; // Use the actual ID of "未設定"
          localStorage.setItem(LOCALSTORAGE_CURRENT_HG_ID_KEY, currentHuntingGroundId.toString());
        } else {
          // Fallback if "未設定" couldn't be found/created (should not happen)
          currentHuntingGroundId = UNSET_HUNTING_GROUND_ID;
        }
      }
    }

    async function getHuntingGroundByName(name) {
      await initDB();
      const tx = db.transaction(HUNTING_GROUND_STORE_NAME, 'readonly');
      const store = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      const index = store.index('name');
      return await index.get(name);
    }


    async function addRecord() {
      const quantityInput = document.getElementById('potionQuantity');
      const quantity = parseInt(quantityInput.value, 10);
      if (isNaN(quantity) || quantity < 0) {
        alert('有効なポーション数量 (0以上の数値) を入力してください。');
        return;
      }
      await initDB();
      const record = {
        timestamp: new Date().getTime(),
        quantity: quantity,
        huntingGroundId: currentHuntingGroundId
      };
      try {
        await db.add(POTION_LOG_STORE_NAME, record);
        localStorage.setItem(LOCALSTORAGE_LAST_QUANTITY_KEY, quantity.toString());
        loadAndProcessDataForCurrentHG();
      } catch (error) {
        console.error('記録の追加に失敗しました:', error);
        alert('記録の追加に失敗しました。コンソールで詳細を確認してください。');
      }
    }

    async function getRecordsForHuntingGround(hgId) {
      await initDB();
      try {
        const tx = db.transaction(POTION_LOG_STORE_NAME, 'readonly');
        const store = tx.objectStore(POTION_LOG_STORE_NAME);
        const index = store.index('huntingGroundId_timestamp');
        return await index.getAll(IDBKeyRange.bound([hgId, -Infinity], [hgId, Infinity]));
      } catch (error) {
        console.error(`ID: ${hgId} の狩り場の記録取得に失敗しました:`, error);
        return [];
      }
    }

    async function requestDeleteRecord(recordId) {
      if (confirm(`この記録を本当に削除しますか？この操作は取り消せません。`)) {
        await deleteSingleRecord(recordId);
      }
    }

    async function deleteSingleRecord(recordId) {
      await initDB();
      try {
        await db.delete(POTION_LOG_STORE_NAME, recordId);
        loadAndProcessDataForCurrentHG();
      } catch (error) {
        console.error(`ID: ${recordId} の記録削除に失敗しました:`, error);
        alert('記録の削除に失敗しました。コンソールで詳細を確認してください。');
      }
    }

    // MODIFIED: clearDataForCurrentHuntingGround function
    async function clearDataForCurrentHuntingGround() {
      const hg = await getHuntingGroundById(currentHuntingGroundId);
      const hgName = hg ? hg.name : "選択された狩り場";
      // 確認メッセージに、消費速度は保持される旨を追記しても良いでしょう。
      if (!confirm(`「${hgName}」の全てのポーション記録を本当に削除しますか？この操作は取り消せません。\n（この狩り場の過去の消費速度データは保持されます）`)) {
        return;
      }
      await initDB();
      try {
        const recordsToDelete = await getRecordsForHuntingGround(currentHuntingGroundId);
        const tx = db.transaction(POTION_LOG_STORE_NAME, 'readwrite');
        const store = tx.objectStore(POTION_LOG_STORE_NAME);
        for (const record of recordsToDelete) {
          await store.delete(record.id);
        }
        await tx.done;

        // 以下の行を削除（またはコメントアウト）しました:
        // await updateHuntingGroundConsumptionRate(currentHuntingGroundId, null); 
        // これにより、この狩り場の lastCalculatedConsumptionRate はDB上で変更されません。

        // loadAndProcessDataForCurrentHG を呼び出すと、記録が0件になるため、
        // calculatePredictionAndConsumptionRate は予測不可と判断します。
        // ただし、その際にDBの消費速度を null で上書きするロジックが calculatePredictionAndConsumptionRate に
        // なければ、DBの値は保持されたままになります。
        // (現在の calculatePredictionAndConsumptionRate のロジックでは、記録不足時はDBを更新しないため問題ありません)
        loadAndProcessDataForCurrentHG();
        alert(`「${hgName}」のポーション記録データが削除されました。`);
      } catch (error) {
        console.error(`「${hgName}」のデータの削除に失敗しました:`, error);
        alert('データの削除に失敗しました。コンソールで詳細を確認してください。');
      }
    }
    // END MODIFIED

    function createLogListItem(record) {
      const listItem = document.createElement('li');
      const logTextSpan = document.createElement('span');
      logTextSpan.classList.add('log-text');
      logTextSpan.textContent = `${formatDateTimeSmart(record.timestamp)} - 数量: ${record.quantity} `;
      listItem.appendChild(logTextSpan);

      const deleteButton = document.createElement('button');
      deleteButton.textContent = '削除';
      deleteButton.classList.add('delete-log-btn');
      deleteButton.onclick = () => requestDeleteRecord(record.id);
      listItem.appendChild(deleteButton);

      return listItem;
    }

    function displayLogs(records) {
      const logListLatestEl = document.getElementById('logListLatest');
      const olderLogsAccordionEl = document.getElementById('olderLogsAccordion');
      const olderLogsSummaryEl = olderLogsAccordionEl.querySelector('summary');
      const logListOlderEl = document.getElementById('logListOlder');
      const noLogsMessageEl = document.getElementById('noLogsMessage');

      logListLatestEl.innerHTML = '';
      logListOlderEl.innerHTML = '';
      olderLogsAccordionEl.style.display = 'none';
      noLogsMessageEl.style.display = 'none';

      if (!records || records.length === 0) {
        noLogsMessageEl.style.display = 'block';
        return;
      }

      const sortedRecords = [...records].sort((a, b) => b.timestamp - a.timestamp);

      const latestLogs = sortedRecords.slice(0, 3);
      const olderLogs = sortedRecords.slice(3);

      latestLogs.forEach(record => {
        logListLatestEl.appendChild(createLogListItem(record));
      });

      if (olderLogs.length > 0) {
        olderLogsAccordionEl.style.display = 'block';
        olderLogsSummaryEl.textContent = `過去の記録を見る (${olderLogs.length}件)`;
        olderLogs.forEach(record => {
          logListOlderEl.appendChild(createLogListItem(record));
        });
      } else {
        olderLogsSummaryEl.textContent = '過去の記録を見る';
      }
    }

    function formatRemainingTime(milliseconds) {
      if (milliseconds <= 0) {
        return "既に枯渇か直後";
      }
      const totalSeconds = Math.floor(milliseconds / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      return `${hours}時間${minutes}分`;
    }

    async function calculatePredictionAndConsumptionRate(records, hgIdToUpdate) {
      const predictionMessageArea = document.getElementById('predictionMessageArea');
      const consumptionRateDisplay = document.getElementById('consumptionRateDisplay');
      // 基本的な戻り値の構造。各プロパティは処理に応じて設定される。
      const baseReturn = {
        prediction: null,
        regressionParams: null,
        residualsStdDev: 0,
        consumptionRatePerMin: null
      };

      predictionMessageArea.innerHTML = ''; // 以前の予測メッセージをクリア
      // consumptionRateDisplay.textContent = ''; // 初期化は各条件分岐内で行う

      // 現状の狩り場データをDBから取得し、既存の消費速度を確認
      const hgData = await getHuntingGroundById(hgIdToUpdate);
      let existingDbRate = null;
      if (hgData && hgData.lastCalculatedConsumptionRate !== null && hgData.lastCalculatedConsumptionRate !== undefined) {
        existingDbRate = hgData.lastCalculatedConsumptionRate;
      }

      // --- ケース1: 記録が不足している場合 ---
      if (!records || records.length < 2) {
        predictionMessageArea.innerHTML = '<p>まだ予測できません。最低2つの記録が必要です。</p>';
        if (existingDbRate !== null) {
          consumptionRateDisplay.textContent = `保存された消費速度: 約 ${existingDbRate.toFixed(2)} 個/分 (記録不足で再計算不可)`;
        } else {
          consumptionRateDisplay.textContent = `消費速度: 計算不可 (記録不足)`;
        }
        // DBは更新せず、DBから読み取ったレート (またはnull) を返す
        return { ...baseReturn, consumptionRatePerMin: existingDbRate };
      }

      // --- ケース2: 記録が2件以上あり、計算が可能な場合 ---
      const sortedRecords = [...records].sort((a, b) => a.timestamp - b.timestamp);
      const n = sortedRecords.length;

      const firstTimestampSeconds = sortedRecords[0].timestamp / 1000; // X軸の開始点を0に近づけるため
      const xValues = sortedRecords.map(r => (r.timestamp / 1000) - firstTimestampSeconds);
      const yValues = sortedRecords.map(r => r.quantity);

      let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      for (let i = 0; i < n; i++) {
        sumX += xValues[i];
        sumY += yValues[i];
        sumXY += xValues[i] * yValues[i];
        sumX2 += xValues[i] * xValues[i];
      }

      const m_sec_denominator = (n * sumX2 - sumX * sumX);
      // m_sec: 1秒あたりのポーション変化量 (傾き)
      const m_sec = m_sec_denominator === 0 ? 0 : (n * sumXY - sumX * sumY) / m_sec_denominator;
      // c_sec: t=firstTimestampSeconds におけるポーション予測量 (切片)
      const c_sec = (sumY - m_sec * sumX) / n;

      const regressionParams = { m_sec, c_sec, firstTimestampSeconds };

      let newlyCalculatedRate = null; // 新しく計算された1分あたりの消費速度
      if (m_sec < 0) { // ポーションが消費されている (傾きが負)
        newlyCalculatedRate = Math.abs(m_sec * 60); // 1分あたりの消費量(正数)
        consumptionRateDisplay.textContent = `現在の狩り場の消費速度: 約 ${newlyCalculatedRate.toFixed(2)} 個/分`;
      } else { // ポーションが増加または変化なし (傾きが0以上)
        newlyCalculatedRate = null; // 有効な消費速度はなし
        consumptionRateDisplay.textContent = `現在の狩り場の消費速度: 計算不可 (消費なし/増加傾向)`;
        if (existingDbRate !== null && existingDbRate > 0) { // 過去に有効な消費実績があれば参考表示
          consumptionRateDisplay.textContent += ` (以前の記録では約 ${existingDbRate.toFixed(2)} 個/分)`;
        }
      }

      // DBの狩り場情報にある消費速度を、今回計算した値で更新
      if (hgIdToUpdate !== null && hgIdToUpdate !== undefined) {
        await updateHuntingGroundConsumptionRate(hgIdToUpdate, newlyCalculatedRate);
      }

      // 残差平方和の標準偏差 (予測のばらつきの目安)
      let residualsStdDev = 0;
      if (n > 2) { // 少なくとも3点ないと意味のある標準偏差は出にくい
        let sumSquaredResiduals = 0;
        for (let i = 0; i < n; i++) {
          const predictedY = m_sec * xValues[i] + c_sec;
          sumSquaredResiduals += Math.pow(yValues[i] - predictedY, 2);
        }
        residualsStdDev = Math.sqrt(sumSquaredResiduals / (n - 2)); // 自由度n-2の不偏分散の平方根
      }

      // 予測メッセージの生成
      const latestRecord = sortedRecords[n - 1];
      let predictionText = '';
      let depletionTime = null;
      let depleted = false;

      if (m_sec >= 0 && latestRecord.quantity >= sortedRecords[0].quantity) {
        predictionText = '<p>ポーションが消費されていないか、増えています。枯渇予測はできません。</p>';
      } else if (m_sec === 0 && latestRecord.quantity < sortedRecords[0].quantity) {
        predictionText = '<p>消費量が非常に少ないか、記録間隔が短すぎるため、正確な予測が困難です。</p>';
      } else if (m_sec >= 0) { // 上の条件に当てはまらないが増加傾向の場合
        predictionText = '<p>ポーションが増加傾向にあるため、枯渇予測はできません。</p>';
      } else { // m_sec < 0 (消費している場合)
        if (latestRecord.quantity === 0) {
          predictionText = `<p>ポーションは既に0です。(最終記録: ${formatDateTimeSmart(latestRecord.timestamp)})</p>`;
          depleted = true;
          depletionTime = latestRecord.timestamp;
        } else {
          // 枯渇する時刻のタイムスタンプ (ミリ秒)
          // y = m_sec * x + c_sec で y=0 となる x を求め、 firstTimestampSeconds を足し戻し、ミリ秒に変換
          const depletionTimestampRelativeSec = -c_sec / m_sec;
          depletionTime = (firstTimestampSeconds + depletionTimestampRelativeSec) * 1000;

          if (depletionTime <= latestRecord.timestamp) {
            predictionText = `<p>予測によると、ポーションは既に枯渇しているか、最終記録(${formatDateTimeSmart(latestRecord.timestamp)}: ${latestRecord.quantity}個)直後に枯渇したと考えられます。</p>`;
            depleted = true;
          } else {
            const nowMilliseconds = new Date().getTime();
            const remainingMilliseconds = depletionTime - nowMilliseconds;
            const remainingTimeFormatted = formatRemainingTime(remainingMilliseconds);

            predictionText = `<p>現在のペースで消費すると、ポーションは<strong>約 ${remainingTimeFormatted} 後</strong>に枯渇する見込みです。</p>`;
            predictionText += `<p>(予測枯渇時刻: ${formatDateTimeSmart(depletionTime)})</p>`;

            if (n > 2 && residualsStdDev > 0.1) { // residualsStdDevが非常に小さい場合は信頼区間表示を省略しても良い
              const tDistributionVal = 2.776; // 95%信頼区間、自由度 n-2 (例: n=4なら自由度2でt値は大きい。ここでは仮の値を採用)
              // より正確には自由度に応じたt値を参照すべき。
              // もしくは簡略化して標準偏差の倍数で示す。例: ±1SD, ±2SD
              const marginErrorQuantity = tDistributionVal * residualsStdDev;
              const depletionTimeLowerBoundSec = (- (c_sec + marginErrorQuantity)) / m_sec;
              const depletionTimeUpperBoundSec = (- (c_sec - marginErrorQuantity)) / m_sec;

              const depletionTimeLower = (firstTimestampSeconds + depletionTimeLowerBoundSec) * 1000;
              const depletionTimeUpper = (firstTimestampSeconds + depletionTimeUpperBoundSec) * 1000;

              if (depletionTimeLower < depletionTimeUpper && depletionTimeLower > nowMilliseconds) {
                predictionText += `<p class="confidence-interval" style="font-size:0.9em; color:#555;">(予測のばらつきを考慮すると、枯渇は ${formatDateTimeSmart(depletionTimeLower)} から ${formatDateTimeSmart(depletionTimeUpper)} の間になる可能性があります。)</p>`;
              }
            }
          }
        }
      }
      predictionMessageArea.innerHTML = predictionText;

      return {
        prediction: depletionTime ? { depleted, depletionTime } : null,
        regressionParams,
        residualsStdDev,
        consumptionRatePerMin: newlyCalculatedRate
      };
    }

    function renderChart(records, predictionResult) {
      const ctx = document.getElementById('potionChart').getContext('2d');

      if (chartInstance) {
        chartInstance.destroy();
      }

      if (!records || records.length === 0) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        return;
      }

      const sortedRecords = [...records].sort((a, b) => a.timestamp - b.timestamp);

      let lastChartTimestamp;
      const now = new Date().getTime();
      const minFutureSpanFromNow = 1 * 3600 * 1000;
      const defaultFutureSpan = 24 * 3600 * 1000;
      const marginAfterEvent = 1 * 3600 * 1000;

      let targetEndTime = 0;

      if (predictionResult && predictionResult.prediction) {
        const { depletionTime, depletionTimeLower, depletionTimeUpper } = predictionResult.prediction;

        if (depletionTimeUpper && depletionTimeUpper > now) {
          targetEndTime = depletionTimeUpper + marginAfterEvent;
        } else if (depletionTimeLower && depletionTimeLower > now) {
          targetEndTime = depletionTimeLower + marginAfterEvent;
        } else if (depletionTime && depletionTime > now) {
          targetEndTime = depletionTime + marginAfterEvent;
        } else {
          targetEndTime = now + defaultFutureSpan;
        }
      } else {
        targetEndTime = now + defaultFutureSpan;
      }

      lastChartTimestamp = Math.max(targetEndTime, now + minFutureSpanFromNow);
      if (sortedRecords.length > 0) {
        lastChartTimestamp = Math.max(lastChartTimestamp, sortedRecords[sortedRecords.length - 1].timestamp + minFutureSpanFromNow);
      }


      const datasets = [{
        label: '実際のポーション数量',
        data: sortedRecords.map(r => ({ x: r.timestamp, y: r.quantity })),
        borderColor: 'rgb(26, 115, 232)',
        backgroundColor: 'rgba(26, 115, 232, 0.1)',
        tension: 0.1,
        fill: false,
        pointRadius: 5,
        pointHoverRadius: 7,
      }];

      if (predictionResult && predictionResult.regressionParams && predictionResult.regressionParams.m_sec < 0) {
        const { m_sec, c_sec, firstTimestampSeconds } = predictionResult.regressionParams;
        const residualsStdDev = predictionResult.residualsStdDev || 0;

        const predictionLine = [];
        const upperBand = [];
        const lowerBand = [];

        const firstChartTimestamp = sortedRecords[0].timestamp;
        const extendedLastChartTimestamp = Math.max(lastChartTimestamp, predictionResult.prediction?.depletionTimeUpper || 0, predictionResult.prediction?.depletionTime || 0);

        const numPredictionPoints = 100;
        const actualStartForPrediction = Math.min(firstChartTimestamp, extendedLastChartTimestamp);
        const step = (extendedLastChartTimestamp - actualStartForPrediction) / Math.max(1, (numPredictionPoints - 1));

        if (extendedLastChartTimestamp > actualStartForPrediction) {
          for (let i = 0; i < numPredictionPoints; i++) {
            const currentTs = actualStartForPrediction + i * step;
            const currentElapsedSeconds = (currentTs / 1000) - firstTimestampSeconds;
            const predictedQty = Math.max(0, m_sec * currentElapsedSeconds + c_sec);
            predictionLine.push({ x: currentTs, y: predictedQty });

            if (sortedRecords.length > 2 && residualsStdDev > 0) {
              upperBand.push({ x: currentTs, y: Math.max(0, predictedQty + residualsStdDev) });
              lowerBand.push({ x: currentTs, y: Math.max(0, predictedQty - residualsStdDev) });
            }
          }
        } else {
          const currentElapsedSeconds = (actualStartForPrediction / 1000) - firstTimestampSeconds;
          const predictedQty = Math.max(0, m_sec * currentElapsedSeconds + c_sec);
          predictionLine.push({ x: actualStartForPrediction, y: predictedQty });
          if (sortedRecords.length > 2 && residualsStdDev > 0) {
            upperBand.push({ x: actualStartForPrediction, y: Math.max(0, predictedQty + residualsStdDev) });
            lowerBand.push({ x: actualStartForPrediction, y: Math.max(0, predictedQty - residualsStdDev) });
          }
        }

        if (predictionResult.prediction && predictionResult.prediction.depletionTime &&
          predictionResult.prediction.depletionTime >= actualStartForPrediction && predictionResult.prediction.depletionTime <= extendedLastChartTimestamp) {
          const depletionElapsed = (predictionResult.prediction.depletionTime / 1000) - firstTimestampSeconds;
          const depletionPointY = Math.max(0, m_sec * depletionElapsed + c_sec);
          const depletionPoint = { x: predictionResult.prediction.depletionTime, y: depletionPointY };
          if (!predictionLine.find(p => p.x === depletionPoint.x)) {
            predictionLine.push(depletionPoint);
            predictionLine.sort((a, b) => a.x - b.x);
          }
        }

        datasets.push({
          label: '予測枯渇線',
          data: predictionLine,
          borderColor: 'rgb(217, 48, 37)',
          borderDash: [6, 3],
          tension: 0.1,
          fill: false,
          pointRadius: 0,
        });

        if (sortedRecords.length > 2 && residualsStdDev > 0 && lowerBand.length > 0 && upperBand.length > 0) {
          datasets.push({
            label: '予測範囲',
            data: upperBand,
            borderColor: 'rgba(251, 188, 5, 0.3)',
            backgroundColor: 'rgba(251, 188, 5, 0.1)',
            tension: 0.1,
            fill: '+1',
            pointRadius: 0,
          });
          datasets.push({
            label: '予測範囲_lower_hidden',
            data: lowerBand,
            borderColor: 'rgba(251, 188, 5, 0.3)',
            backgroundColor: 'rgba(251, 188, 5, 0.1)',
            tension: 0.1,
            fill: false,
            pointRadius: 0,
            showInLegend: false,
          });
        }
      }

      const minX = (sortedRecords.length > 0) ? sortedRecords[0].timestamp : now - minFutureSpanFromNow;

      chartInstance = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'hour',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm',
                  hour: 'HH:mm',
                  day: 'MM/dd HH:mm',
                  week: 'MM/dd',
                  month: 'yyyy/MM',
                  quarter: 'yyyy QQ',
                  year: 'yyyy'
                },
                tooltipFormat: 'yyyy/MM/dd HH:mm:ss'
              },
              ticks: {
                callback: function (value, index, ticks) {
                  return formatDateTimeSmart(value);
                },
                maxRotation: 70,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: 10
              },
              title: { display: true, text: '時刻', font: { size: 14 } },
              grid: { color: '#e0e0e0' },
              min: minX,
              max: lastChartTimestamp
            },
            y: {
              beginAtZero: true,
              title: { display: true, text: 'ポーション数量', font: { size: 14 } },
              grid: { color: '#e0e0e0' }
            }
          },
          plugins: {
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0,0,0,0.8)',
              titleFont: { size: 14 },
              bodyFont: { size: 12 },
              padding: 10,
              callbacks: {
                title: function (tooltipItems) {
                  if (tooltipItems.length > 0) {
                    const timestamp = tooltipItems[0].parsed.x;
                    return formatDateTimeSmart(timestamp);
                  }
                  return '';
                }
              }
            },
            legend: {
              position: 'bottom',
              labels: {
                font: { size: 12 },
                filter: function (legendItem, chartData) {
                  return legendItem.text !== '予測範囲_lower_hidden';
                }
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    // --- Hunting Ground Specific Functions ---
    async function openHuntingGroundModal() {
      await loadHuntingGroundsForModal();
      document.getElementById('huntingGroundModal').style.display = 'block';
    }

    function closeHuntingGroundModal() {
      document.getElementById('huntingGroundModal').style.display = 'none';
    }

    async function loadHuntingGroundsForModal() {
      await initDB();
      const tx = db.transaction(HUNTING_GROUND_STORE_NAME, 'readonly');
      const store = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      const allHGs = await store.getAll();
      await tx.done;

      const hgListEl = document.getElementById('huntingGroundList');
      const noHGsMessageEl = document.getElementById('noHuntingGroundsMessage');
      hgListEl.innerHTML = '';

      const userDefinedHGs = allHGs.filter(hg => hg.id !== UNSET_HUNTING_GROUND_ID);

      if (userDefinedHGs.length === 0 && allHGs.length <= 1) { // Check if only "Unset" (or none if issue) exists
        noHGsMessageEl.style.display = 'block';
      } else {
        noHGsMessageEl.style.display = 'none';
      }

      const unsetHGFromDB = allHGs.find(hg => hg.id === UNSET_HUNTING_GROUND_ID || hg.name === UNSET_HUNTING_GROUND_NAME);
      const displayList = [];

      if (unsetHGFromDB) {
        displayList.push(unsetHGFromDB);
      } else {
        // Fallback if "Unset" is somehow not in DB (should be created by ensureUnsetHuntingGroundExists)
        displayList.push({ id: UNSET_HUNTING_GROUND_ID, name: UNSET_HUNTING_GROUND_NAME, lastCalculatedConsumptionRate: null });
      }

      userDefinedHGs.sort((a, b) => a.name.localeCompare(b.name)).forEach(hg => {
        if (hg.id !== unsetHGFromDB?.id) { // Avoid duplicating "Unset" if it was in userDefinedHGs
          displayList.push(hg);
        }
      });
      // Ensure unique entries if there was an issue with UNSET_HUNTING_GROUND_ID vs actual ID
      const uniqueDisplayList = Array.from(new Map(displayList.map(item => [item.id, item])).values());


      uniqueDisplayList.forEach(hg => {
        const listItem = document.createElement('li');

        const nameSpan = document.createElement('span');
        nameSpan.textContent = hg.name;
        nameSpan.style.fontWeight = (hg.id === currentHuntingGroundId) ? 'bold' : 'normal';
        listItem.appendChild(nameSpan);

        const detailsSpan = document.createElement('span');
        let rateText = "-";
        if (hg.lastCalculatedConsumptionRate !== null && hg.lastCalculatedConsumptionRate !== undefined) {
          rateText = `${hg.lastCalculatedConsumptionRate.toFixed(2)} 個/分`;
        }
        const consumptionSpan = document.createElement('span');
        consumptionSpan.className = 'hg-consumption-rate';
        consumptionSpan.textContent = `消費: ${rateText}`;
        detailsSpan.appendChild(consumptionSpan);

        listItem.onclick = () => selectHuntingGround(hg.id);

        // Only allow deletion if it's not the special "Unset" hunting ground by its canonical ID or name
        if (hg.id !== UNSET_HUNTING_GROUND_ID && hg.name !== UNSET_HUNTING_GROUND_NAME) {
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = '削除';
          deleteBtn.classList.add('small-btn', 'danger');
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            requestDeleteHuntingGround(hg.id, hg.name);
          };
          detailsSpan.appendChild(deleteBtn);
        }
        listItem.appendChild(detailsSpan);
        hgListEl.appendChild(listItem);
      });

      const currentHG = await getHuntingGroundById(currentHuntingGroundId);
      document.getElementById('currentHuntingGroundDisplay').textContent = currentHG ? currentHG.name : UNSET_HUNTING_GROUND_NAME;
    }

    async function addHuntingGroundHandler() {
      const nameInput = document.getElementById('newHuntingGroundName');
      const name = nameInput.value.trim();
      if (!name) {
        alert('狩り場名を入力してください。');
        return;
      }
      if (name === UNSET_HUNTING_GROUND_NAME) {
        alert(`「${UNSET_HUNTING_GROUND_NAME}」という名前は予約されているため使用できません。`);
        return;
      }
      await initDB();
      try {
        const existing = await getHuntingGroundByName(name);
        if (existing) {
          alert('その狩り場名は既に使用されています。');
          return;
        }

        const tx = db.transaction(HUNTING_GROUND_STORE_NAME, 'readwrite');
        const store = tx.objectStore(HUNTING_GROUND_STORE_NAME);
        const newHgId = await store.add({ name: name, lastCalculatedConsumptionRate: null });
        await tx.done;

        nameInput.value = '';

        const allHGs = await db.getAll(HUNTING_GROUND_STORE_NAME);
        // Check if it's the first *user-defined* HG added
        if (allHGs.filter(hg => hg.id !== UNSET_HUNTING_GROUND_ID && hg.name !== UNSET_HUNTING_GROUND_NAME).length === 1) {
          await selectHuntingGround(newHgId);
        } else {
          await loadHuntingGroundsForModal();
        }

      } catch (error) {
        console.error('狩り場の追加に失敗しました:', error);
        alert('狩り場の追加に失敗しました。');
      }
    }

    async function getHuntingGroundById(id) {
      if (id === null || id === undefined) return null;
      await initDB();
      // If the target ID is the canonical UNSET_HUNTING_GROUND_ID, ensure we fetch by it.
      // Otherwise, if the actual ID of "未設定" in DB differs, this could return the wrong one
      // if another HG coincidentally got ID 0.
      // The ensureUnsetHuntingGroundExists and localStorage logic should try to keep currentHuntingGroundId
      // consistent with the *actual* ID of "未設定".
      let hg = await db.get(HUNTING_GROUND_STORE_NAME, id);
      // If ID is UNSET_HUNTING_GROUND_ID but nothing found, or name doesn't match, try by name.
      // This handles cases where "未設定"'s ID might not be 0.
      if (id === UNSET_HUNTING_GROUND_ID && (!hg || hg.name !== UNSET_HUNTING_GROUND_NAME)) {
        hg = await getHuntingGroundByName(UNSET_HUNTING_GROUND_NAME);
      }
      return hg;
    }


    async function selectHuntingGround(hgId) {
      const hg = await getHuntingGroundById(hgId); // This now tries to resolve UNSET_HUNTING_GROUND_ID correctly
      if (!hg) {
        console.warn(`狩り場ID ${hgId} が見つかりません。「${UNSET_HUNTING_GROUND_NAME}」に戻します。`);
        const unsetHg = await getHuntingGroundByName(UNSET_HUNTING_GROUND_NAME);
        currentHuntingGroundId = unsetHg ? unsetHg.id : UNSET_HUNTING_GROUND_ID; // Fallback to default const if name not found
      } else {
        currentHuntingGroundId = hg.id;
      }

      localStorage.setItem(LOCALSTORAGE_CURRENT_HG_ID_KEY, currentHuntingGroundId.toString());
      await loadAndProcessDataForCurrentHG();
      await loadHuntingGroundsForModal();
      closeHuntingGroundModal();
    }

    async function requestDeleteHuntingGround(hgId, hgName) {
      if (hgId === UNSET_HUNTING_GROUND_ID || hgName === UNSET_HUNTING_GROUND_NAME) {
        alert(`「${UNSET_HUNTING_GROUND_NAME}」の狩り場は削除できません。`);
        return;
      }
      if (confirm(`狩り場「${hgName}」を削除しますか？\nこの狩り場に関連する全てのポーション記録も削除されます。この操作は取り消せません。`)) {
        await deleteHuntingGround(hgId);
      }
    }

    async function deleteHuntingGround(hgId) {
      // Double check it's not the UNSET one by its canonical ID or actual ID if "未設定" has a different ID
      const targetHg = await getHuntingGroundById(hgId);
      if (!targetHg || targetHg.name === UNSET_HUNTING_GROUND_NAME) {
        console.warn("Attempted to delete the 'Unset' hunting ground via its actual ID. Operation cancelled.");
        alert(`「${UNSET_HUNTING_GROUND_NAME}」の狩り場は削除できません。`);
        return;
      }
      if (hgId === UNSET_HUNTING_GROUND_ID) return; // Should be caught by above, but as a safeguard

      await initDB();
      const tx = db.transaction([HUNTING_GROUND_STORE_NAME, POTION_LOG_STORE_NAME], 'readwrite');
      const hgStore = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      const logStore = tx.objectStore(POTION_LOG_STORE_NAME);
      const logIndex = logStore.index('huntingGroundId_timestamp');

      try {
        let recordsToDelete = await logStore.index('huntingGroundId_timestamp').getAll(IDBKeyRange.bound([hgId, -Infinity], [hgId, Infinity]));
        for (const record of recordsToDelete) {
          await logStore.delete(record.id);
        }

        await hgStore.delete(hgId);
        await tx.done;

        if (currentHuntingGroundId === hgId) {
          const unsetHG = await getHuntingGroundByName(UNSET_HUNTING_GROUND_NAME);
          await selectHuntingGround(unsetHG ? unsetHG.id : UNSET_HUNTING_GROUND_ID);
        } else {
          await loadHuntingGroundsForModal();
        }
        alert('狩り場と関連データが削除されました。');
      } catch (error) {
        console.error('狩り場の削除に失敗:', error);
        alert('狩り場の削除に失敗しました。');
        if (tx.error && tx.abort) await tx.abort();
      }
    }

    async function clearAllUserHuntingGrounds() {
      if (!confirm('「未設定」以外の全ての狩り場と、それらに関連する全ポーション記録を削除しますか？この操作は取り消せません。')) {
        return;
      }
      await initDB();
      const tx = db.transaction([HUNTING_GROUND_STORE_NAME, POTION_LOG_STORE_NAME], 'readwrite');
      const hgStore = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      const logStore = tx.objectStore(POTION_LOG_STORE_NAME);
      const logHgIndex = logStore.index('huntingGroundId_timestamp');
      const unsetHG = await getHuntingGroundByName(UNSET_HUNTING_GROUND_NAME); // Get the actual "Unset" record
      const actualUnsetID = unsetHG ? unsetHG.id : UNSET_HUNTING_GROUND_ID; // Use its actual ID for comparison

      try {
        const allHGs = await hgStore.getAll();
        for (const hg of allHGs) {
          if (hg.id !== actualUnsetID && hg.name !== UNSET_HUNTING_GROUND_NAME) { // Compare with actual Unset ID and name
            let recordsToDelete = await logHgIndex.getAll(IDBKeyRange.bound([hg.id, -Infinity], [hg.id, Infinity]));
            for (const record of recordsToDelete) {
              await logStore.delete(record.id);
            }
            await hgStore.delete(hg.id);
          }
        }
        await tx.done;

        if (currentHuntingGroundId !== actualUnsetID) {
          await selectHuntingGround(actualUnsetID);
        } else {
          await loadAndProcessDataForCurrentHG();
          await loadHuntingGroundsForModal();
        }
        alert('「未設定」以外の全ての狩り場と関連データが削除されました。');
      } catch (error) {
        console.error('全狩り場削除に失敗:', error);
        alert('全狩り場削除に失敗しました。');
        if (tx.error && tx.abort) await tx.abort();
      }
    }

    async function updateHuntingGroundConsumptionRate(hgId, rate) {
      if (hgId === null || hgId === undefined) return;
      await initDB();
      const tx = db.transaction(HUNTING_GROUND_STORE_NAME, 'readwrite');
      const store = tx.objectStore(HUNTING_GROUND_STORE_NAME);
      const hg = await store.get(hgId); // Get by actual ID
      if (hg) {
        hg.lastCalculatedConsumptionRate = rate;
        await store.put(hg);
      }
      await tx.done;
    }

    async function updateCurrentHG_UI() {
      const hg = await getHuntingGroundById(currentHuntingGroundId);
      const hgName = hg ? hg.name : UNSET_HUNTING_GROUND_NAME;
      if (hgName != UNSET_HUNTING_GROUND_NAME) {
        document.getElementById('inputSectionTitle').textContent = `入力 (${hgName})`;
        document.getElementById('clearDataButton').textContent = `「${hgName}」の入力履歴削除`;
      } else {
        document.getElementById('inputSectionTitle').textContent = `入力`;
        document.getElementById('clearDataButton').textContent = `入力履歴削除`;

      }
      const currentHGDisplayEl = document.getElementById('currentHuntingGroundDisplay');
      if (currentHGDisplayEl) currentHGDisplayEl.textContent = hgName;
    }

    async function loadAndProcessDataForCurrentHG() {
      const quantityInput = document.getElementById('potionQuantity');
      const lastQuantity = localStorage.getItem(LOCALSTORAGE_LAST_QUANTITY_KEY);
      if (lastQuantity !== null) {
        const parsedLastQuantity = parseInt(lastQuantity, 10);
        if (!isNaN(parsedLastQuantity) && parsedLastQuantity >= 0) {
          quantityInput.value = parsedLastQuantity;
        }
      }

      await initDB();
      await updateCurrentHG_UI();

      const records = await getRecordsForHuntingGround(currentHuntingGroundId);
      displayLogs(records);
      const predictionResult = await calculatePredictionAndConsumptionRate(records, currentHuntingGroundId);
      renderChart(records, predictionResult);
    }

    window.onload = async () => {
      await initDB();
      await loadAndProcessDataForCurrentHG();

      window.onclick = function (event) {
        const modal = document.getElementById('huntingGroundModal');
        if (event.target == modal) {
          closeHuntingGroundModal();
        }
      }
    };

  </script>
</body>

</html>