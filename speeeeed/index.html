<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>RAIS-bU</title>
  <link rel="icon" href="data:,">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      font-family: 'Arial Black', sans-serif;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      text-shadow: 0 0 5px #00aaff;
      z-index: 100;
      pointer-events: none;
      background: rgba(0, 20, 40, 0.6);
      padding: 10px;
      border-radius: 8px;
      border-left: 5px solid #00ff00;
      width: 220px;
      transform-origin: top left;
      transform: scale(0.9);
    }

    #timer-row {
      font-size: 20px;
      color: #fff;
      border-bottom: 1px solid #444;
      margin-bottom: 5px;
      padding-bottom: 2px;
    }

    #speed-row {
      font-size: 24px;
      color: #00ff00;
      font-style: italic;
    }

    .unit {
      font-size: 12px;
      color: #ccc;
      font-style: normal;
    }

    #warp-info {
      font-size: 10px;
      color: #0af;
      display: flex;
      justify-content: space-between;
      margin-top: 2px;
    }

    #warp-container {
      width: 100%;
      height: 4px;
      background: #222;
      margin-bottom: 5px;
    }

    #warp-bar {
      width: 0%;
      height: 100%;
      background: #00ffff;
      transition: width 0.1s;
    }

    #score-row {
      font-size: 14px;
      color: #ffcc00;
      margin-bottom: 2px;
    }

    #hp-container {
      width: 100%;
      height: 8px;
      background: #333;
      border: 1px solid #555;
      margin-top: 5px;
    }

    #hp-bar {
      width: 100%;
      height: 100%;
      background: #00ff00;
      transition: width 0.2s;
    }

    #top-right-ui {
      position: absolute;
      top: 10px;
      right: 10px;
      text-align: right;
      pointer-events: auto;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
    }

    .label-box {
      background: rgba(0, 0, 0, 0.6);
      padding: 5px 10px;
      border: 1px solid #00ff00;
      color: #00ff00;
      font-size: 14px;
      margin-bottom: 5px;
      display: inline-block;
    }

    #cam-label {
      color: #ffaa00;
      border-color: #ffaa00;
      display: none;
    }

    #btn-view {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 0, 0.3);
      border: 2px solid #ffff00;
      color: #ffff00;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 0 5px #ffff00;
    }

    #btn-view:active {
      transform: scale(0.9);
      background: rgba(255, 255, 0, 0.6);
    }

    #hud-reticle {
      position: absolute;
      top: 0;
      left: 0;
      width: 100px;
      height: 100px;
      border: 2px solid rgba(0, 255, 0, 0.4);
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
      pointer-events: none;
      z-index: 90;
      transform: translate(-50%, -50%);
      display: none;
    }

    #hud-reticle::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 4px;
      background: #00ff00;
      border-radius: 50%;
      box-shadow: 0 0 5px #fff;
    }

    #lock-container,
    #effect-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 95;
      overflow: hidden;
    }

    .lock-wrapper {
      position: absolute;
      width: 60px;
      height: 60px;
      transform: translate(-50%, -50%);
    }

    .lock-bracket {
      width: 100%;
      height: 100%;
      border: 2px solid #00ff00;
      box-shadow: 0 0 8px #00ff00;
      clip-path: polygon(0% 0%, 25% 0%, 25% 10%, 10% 10%, 10% 25%, 0% 25%, 0% 75%, 10% 75%, 10% 90%, 25% 90%, 25% 100%, 0% 100%, 0% 100%, 100% 100%, 100% 75%, 90% 75%, 90% 90%, 75% 90%, 75% 100%, 100% 100%, 100% 0%, 75% 0%, 75% 10%, 90% 10%, 90% 25%, 100% 25%);
    }

    .lock-info {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      color: #00ff00;
      font-size: 12px;
      font-family: monospace;
      font-weight: bold;
      text-shadow: 0 0 2px #000;
      white-space: nowrap;
      text-align: center;
      margin-top: 4px;
    }

    .lock-label {
      font-size: 10px;
      color: #aaffaa;
      display: block;
      line-height: 1;
    }

    .lock-marker.destroyed {
      position: absolute;
      width: 60px;
      height: 60px;
      border: 2px solid #ff0000;
      box-shadow: 0 0 15px #ff0000;
      transform: translate(-50%, -50%);
      clip-path: polygon(0% 0%, 25% 0%, 25% 10%, 10% 10%, 10% 25%, 0% 25%, 0% 75%, 10% 75%, 10% 90%, 25% 90%, 25% 100%, 0% 100%, 0% 100%, 100% 100%, 100% 75%, 90% 75%, 90% 90%, 75% 90%, 75% 100%, 100% 100%, 100% 0%, 75% 0%, 75% 10%, 90% 10%, 90% 25%, 100% 25%);
      animation: fadeOut 0.4s forwards;
    }

    .lock-marker.destroyed::before,
    .lock-marker.destroyed::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 70%;
      height: 3px;
      background: #ff0000;
      box-shadow: 0 0 5px #fff;
    }

    .lock-marker.destroyed::before {
      transform: translate(-50%, -50%) rotate(45deg);
    }

    .lock-marker.destroyed::after {
      transform: translate(-50%, -50%) rotate(-45deg);
    }

    @keyframes fadeOut {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }

      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
    }

    #damage-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: red;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 0.1s;
    }

    #center-msg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0af;
      letter-spacing: 2px;
      font-weight: bold;
      pointer-events: none;
      z-index: 200;
      text-shadow: 0 0 10px #000;
      text-align: center;
      display: none;
    }

    #result-screen {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 20, 40, 0.95);
      border: 2px solid #00aaff;
      padding: 20px;
      text-align: center;
      z-index: 300;
      color: white;
      border-radius: 10px;
      min-width: 300px;
    }

    input[type="text"] {
      font-size: 16px;
      padding: 8px;
      width: 70%;
      background: #000;
      border: 1px solid #0af;
      color: white;
      text-align: center;
      margin: 10px 0;
    }

    button {
      font-size: 16px;
      padding: 10px 20px;
      border: none;
      cursor: pointer;
      font-weight: bold;
      margin: 5px;
      background: #00aaff;
      color: #000;
    }

    #ranking-list {
      text-align: left;
      margin-top: 15px;
      font-size: 12px;
      color: #ccc;
      font-family: monospace;
      border-top: 1px solid #444;
      padding-top: 10px;
    }

    .rank-row {
      display: flex;
      justify-content: space-between;
      padding: 2px 0;
    }

    #click-catcher {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 150;
      cursor: pointer;
    }

    #mobile-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 200;
      pointer-events: none;
    }

    #joystick-zone {
      position: absolute;
      bottom: 40px;
      left: 30px;
      width: 150px;
      height: 150px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 50%;
      pointer-events: auto;
    }

    #joystick-knob {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      background: rgba(0, 255, 255, 0.6);
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      box-shadow: 0 0 10px #0af;
    }

    #action-area {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 200px;
      pointer-events: none;
    }

    .act-btn {
      position: absolute;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: bold;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      pointer-events: auto;
      transition: transform 0.1s;
    }

    .act-btn:active {
      transform: scale(0.9) !important;
      opacity: 0.8;
      filter: brightness(1.2);
    }

    #btn-mode {
      bottom: 0;
      right: 0;
      width: 110px;
      height: 110px;
      font-size: 18px;
      background: rgba(0, 255, 0, 0.4);
      border: 2px solid #00ff00;
      z-index: 10;
    }

    #btn-shot {
      bottom: 10px;
      right: 120px;
      width: 60px;
      height: 60px;
      font-size: 10px;
      background: rgba(0, 120, 255, 0.4);
      border: 2px solid #00ccff;
      line-height: 1.1;
      text-align: center;
    }

    #btn-bomb {
      bottom: 120px;
      right: 10px;
      width: 60px;
      height: 60px;
      font-size: 10px;
      background: rgba(255, 60, 0, 0.4);
      border: 2px solid #ffaa00;
      line-height: 1.1;
      text-align: center;
    }

    #title-screen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 200;
      width: 100%;
      pointer-events: none;
    }

    .main-title {
      font-size: 50px;
      color: #00aaff;
      text-shadow: 0 0 20px #00aaff;
      font-style: italic;
      margin-bottom: 10px;
      line-height: 1.1;
    }

    .sub-title {
      font-size: 18px;
      color: #ffffff;
      margin-bottom: 5px;
      letter-spacing: 1px;
    }

    .flavor-text {
      font-size: 14px;
      color: #88ccff;
      margin-bottom: 40px;
      font-weight: normal;
    }

    .click-msg {
      font-size: 20px;
      color: #ffdd00;
      animation: blink 1s infinite;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.3
      }
    }
  </style>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>
</head>

<body>
  <div id="damage-overlay"></div>

  <div id="title-screen">
    <div class="main-title">Running Away is Shameful, but Useful</div>
    <div class="sub-title">RAIS-bU</div>
    <div class="flavor-text">- 逃げるは恥だが役に立つ…！脱出速度を競うゲーム -</div>
    <div class="click-msg">TAP SCREEN TO START</div>
  </div>

  <div id="center-msg"></div>
  <div id="click-catcher"></div>

  <div id="hud-reticle"></div>
  <div id="lock-container"></div>
  <div id="effect-container"></div>

  <div id="top-right-ui">
    <div id="mode-label" class="label-box">MODE: JET</div>
    <div id="cam-label" class="label-box">CAM: INSPECT</div>
    <div id="btn-view">ZOOM</div>
  </div>

  <div id="ui" style="display:none;">
    <div id="timer-row">TIME: <span id="timer">00:00.000</span></div>
    <div id="speed-row"><span id="speed-val">0</span> <span class="unit">km/h</span></div>
    <div id="warp-info"><span id="stage-name">STAGE 1</span><span>WARP CHARGE</span></div>
    <div id="warp-container">
      <div id="warp-bar"></div>
    </div>
    <div id="score-row">SCORE: <span id="score">0</span></div>
    <div id="hp-container">
      <div id="hp-bar"></div>
    </div>
  </div>
  <div id="result-screen">
    <h2 style="color:#ffdd00; margin:0 0 10px 0;">MISSION COMPLETE</h2>
    <div style="font-size:30px; margin:10px 0;" id="final-time">00:00.000</div>
    <input type="text" id="pilot-name" placeholder="PILOT NAME" maxlength="10">
    <br>
    <button id="btn-tweet">SHARE</button>
    <button id="btn-restart">RESTART</button>
    <div id="ranking-list">
      <div>LOCAL RANKING</div>
      <div id="ranking-content"></div>
    </div>
  </div>
  <div id="mobile-controls" style="display:none;">
    <div id="joystick-zone">
      <div id="joystick-knob"></div>
    </div>
    <div id="action-area">
      <div id="btn-mode" class="act-btn" data-key="c">FORM</div>
      <div id="btn-bomb" class="act-btn" data-key="z">STOP<br>BOMB</div>
      <div id="btn-shot" class="act-btn" data-key=" ">STOP<br>SHOT</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import {
      UnrealBloomPass
    } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import {
      EffectComposer
    } from 'three/addons/postprocessing/EffectComposer.js';
    import {
      RenderPass
    } from 'three/addons/postprocessing/RenderPass.js';
    import {
      MathUtils
    } from 'three';

    const DENSITY_SETTINGS = {
      reductionStart: 5000,
      reductionStrength: 0.5
    };
    const CFG = {
      initSpeed: 1.5,
      maxSpeed: 16.0,
      speedUpPerKill: 0.2,
      speedDownPerHit: 2.0,
      playerMoveSpeed: 1.2,
      shotSpeed: 8.0,
      missileSpeed: 5.0,
      maxHP: 100,
      fogDist: 1800,
      skyTop: '#0044aa',
      skyBottom: '#44aaff'
    };
    const STAGES = [{
        target: 8.0,
        name: "STAGE 1: BLUE SKY",
        skyTop: '#0044aa',
        skyBottom: '#44aaff',
        ground: '#44aaff',
        fog: '#44aaff'
      },
      {
        target: 12.0,
        name: "STAGE 2: DESERT",
        skyTop: '#2255aa',
        skyBottom: '#aaccff',
        ground: '#eebb44',
        fog: '#eebb44'
      },
      {
        target: 16.0,
        name: "STAGE 3: DEEP SPACE",
        skyTop: '#000000',
        skyBottom: '#000022',
        ground: '#000000',
        fog: '#000000'
      }
    ];
    // ★追加: タイトル画面用の宇宙設定
    const TITLE_STAGE = {
      skyTop: '#000000',
      skyBottom: '#000011',
      fog: '#000000'
    };

    let gameState = 'INIT';
    let gameSpeed = CFG.initSpeed;
    let worldZ = 0;
    let currentHP = CFG.maxHP;
    let score = 0;
    let frame = 0;
    let currentStageIdx = 0;
    let startTime = 0;
    let elapsed = 0;
    let stageStartTime = 0;
    let lockedEnemies = [];
    let isDroneMode = false;
    let isInspectMode = false;
    let droneSightMesh = null;

    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false,
      " ": false,
      z: false,
      c: false,
      v: false
    };
    const joyInput = {
      x: 0,
      y: 0
    };

    function setupControls() {
      window.addEventListener('keydown', e => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
        if (e.key.toLowerCase() === 'c') toggleDroneMode();
        if (e.key.toLowerCase() === 'v') toggleInspectMode();
      });
      window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
      });
      const zone = document.getElementById('joystick-zone');
      const knob = document.getElementById('joystick-knob');
      let joyId = null;
      const maxDist = 40;
      const moveKnob = (cx, cy) => {
        const r = zone.getBoundingClientRect();
        const cntX = r.left + r.width / 2,
          cntY = r.top + r.height / 2;
        let dx = cx - cntX,
          dy = cy - cntY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        let nx = dx / maxDist,
          ny = dy / maxDist;
        if (dist > maxDist) {
          const a = Math.atan2(dy, dx);
          dx = Math.cos(a) * maxDist;
          dy = Math.sin(a) * maxDist;
          nx = Math.cos(a);
          ny = Math.sin(a);
        }
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        joyInput.x = nx;
        joyInput.y = ny;
        const th = 0.2;
        keys.ArrowRight = nx > th;
        keys.ArrowLeft = nx < -th;
        keys.ArrowDown = ny > th;
        keys.ArrowUp = ny < -th;
      };
      const resetKnob = () => {
        knob.style.transform = `translate(-50%, -50%)`;
        joyInput.x = 0;
        joyInput.y = 0;
        keys.ArrowRight = keys.ArrowLeft = keys.ArrowDown = keys.ArrowUp = false;
        joyId = null;
      };
      zone.addEventListener('touchstart', e => {
        e.preventDefault();
        if (joyId !== null) return;
        const t = e.changedTouches[0];
        joyId = t.identifier;
        moveKnob(t.clientX, t.clientY);
      }, {
        passive: false
      });
      zone.addEventListener('touchmove', e => {
        e.preventDefault();
        if (joyId === null) return;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joyId) {
            moveKnob(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            break;
          }
        }
      }, {
        passive: false
      });
      zone.addEventListener('touchend', e => {
        e.preventDefault();
        if (joyId === null) return;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === joyId) {
            resetKnob();
            break;
          }
        }
      }, {
        passive: false
      });

      const btnMode = document.getElementById('btn-mode');
      btnMode.addEventListener('touchstart', e => {
        e.preventDefault();
        toggleDroneMode();
        btnMode.style.transform = "scale(0.9)";
      }, {
        passive: false
      });
      btnMode.addEventListener('touchend', e => {
        e.preventDefault();
        btnMode.style.transform = "scale(1)";
      }, {
        passive: false
      });
      btnMode.addEventListener('mousedown', () => {
        toggleDroneMode();
        btnMode.style.transform = "scale(0.9)";
      });
      btnMode.addEventListener('mouseup', () => {
        btnMode.style.transform = "scale(1)";
      });

      const btnView = document.getElementById('btn-view');
      btnView.addEventListener('touchstart', e => {
        e.preventDefault();
        toggleInspectMode();
        btnView.style.transform = "scale(0.9)";
      }, {
        passive: false
      });
      btnView.addEventListener('touchend', e => {
        e.preventDefault();
        btnView.style.transform = "scale(1)";
      }, {
        passive: false
      });
      btnView.addEventListener('mousedown', () => {
        toggleInspectMode();
        btnView.style.transform = "scale(0.9)";
      });
      btnView.addEventListener('mouseup', () => {
        btnView.style.transform = "scale(1)";
      });

      ['btn-shot', 'btn-bomb'].forEach(id => {
        const btn = document.getElementById(id);
        const press = () => {
          keys[btn.dataset.key] = true;
          btn.style.transform = "scale(0.9)";
        };
        const rel = () => {
          keys[btn.dataset.key] = false;
          btn.style.transform = "scale(1)";
        };
        btn.addEventListener('touchstart', e => {
          e.preventDefault();
          press();
        }, {
          passive: false
        });
        btn.addEventListener('touchend', e => {
          e.preventDefault();
          rel();
        }, {
          passive: false
        });
        btn.addEventListener('mousedown', press);
        btn.addEventListener('mouseup', rel);
      });
    }
    setupControls();

    function toggleDroneMode() {
      isDroneMode = !isDroneMode;
      document.getElementById('mode-label').innerText = isDroneMode ? "MODE: DRONE" : "MODE: JET";
      if (isDroneMode) {
        camera.up.set(0, 0, -1);
        document.getElementById('hud-reticle').style.display = 'none';
        if (droneSightMesh) droneSightMesh.visible = true;
      } else {
        camera.up.set(0, 1, 0);
        document.getElementById('hud-reticle').style.display = 'block';
        if (droneSightMesh) droneSightMesh.visible = false;
      }
    }

    function toggleInspectMode() {
      isInspectMode = !isInspectMode;
      document.getElementById('cam-label').style.display = isInspectMode ? 'block' : 'none';
    }

    const scene = new THREE.Scene();

    // [Patch] メモリ管理関数（シーンからの削除とメモリ解放を同時に行う）
    function disposeObj(obj) {
      if (!obj) return;
      
      // 親から削除 (scene.remove と同等の効果)
      if (obj.parent) obj.parent.remove(obj);

      // ジオメトリの解放
      if (obj.geometry) obj.geometry.dispose();

      // マテリアルの解放
      if (obj.material) {
        if (Array.isArray(obj.material)) {
          obj.material.forEach(m => m.dispose());
        } else {
          obj.material.dispose();
        }
      }

      // 子要素も再帰的に処理
      if (obj.children) {
        while(obj.children.length > 0){
          disposeObj(obj.children[0]);
        }
      }
    }
    
    const fogColor = new THREE.Color(CFG.skyBottom);
    scene.fog = new THREE.Fog(fogColor, 100, CFG.fogDist);
    scene.background = fogColor;

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 20000);
    camera.position.set(0, 30, 100);
    let baseFov = 60;

    const renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.8;
    bloomPass.strength = 0.5;
    bloomPass.radius = 0.3;
    composer.addPass(renderPass);
    composer.addPass(bloomPass);

    // ★追加: タイトル画面用のビジュアル設定関数
    function setTitleVisuals() {
      const s = TITLE_STAGE;
      const canvas = skyTexture.image;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createLinearGradient(0, 0, 0, 256);
      grad.addColorStop(0, s.skyTop);
      grad.addColorStop(0.8, s.skyBottom);
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 256);
      skyTexture.needsUpdate = true;
      scene.fog.color.set(s.fog);
      sea.visible = false; // 宇宙なので海は非表示
    }

    function setStageVisuals(idx) {
      const s = STAGES[idx];
      const canvas = skyTexture.image;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createLinearGradient(0, 0, 0, 256);
      grad.addColorStop(0, s.skyTop);
      grad.addColorStop(0.6, s.skyBottom);
      grad.addColorStop(1, idx === 2 ? '#000000' : '#ffffff');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 256);
      skyTexture.needsUpdate = true;

      scene.fog.color.set(s.fog);

      if (idx === 2) {
        sea.visible = false;
      } else {
        sea.visible = true;
        sea.material.color.set(s.ground);
      }
    }

    function createSkyGradient() {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, 32, 256);
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    const skyTexture = createSkyGradient();
    scene.background = skyTexture;
    scene.environment = skyTexture;

    const seaGeo = new THREE.PlaneGeometry(20000, 20000);
    const seaMat = new THREE.MeshBasicMaterial({
      color: CFG.skyBottom,
      transparent: true,
      opacity: 0.9
    });
    const sea = new THREE.Mesh(seaGeo, seaMat);
    sea.rotation.x = -Math.PI / 2;
    sea.position.y = -150;
    scene.add(sea);

    let buildings = [];
    const buildingMat = new THREE.MeshStandardMaterial({
      color: 0x8899aa,
      roughness: 0.2,
      metalness: 0.8,
      envMap: scene.environment,
      envMapIntensity: 1.0
    });

    function createBuilding(x, z) {
      const width = 20 + Math.random() * 40;
      const depth = 20 + Math.random() * 40;
      const height = 100 + Math.random() * 500;
      const geo = new THREE.BoxGeometry(width, height, depth);
      const mesh = new THREE.Mesh(geo, buildingMat);
      const yPos = (Math.random() - 0.5) * 300 - 50;
      mesh.position.set(x, yPos, z);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      mesh.geometry.computeBoundingBox();
      return mesh;
    }

    const dustCount = 1500;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    for (let i = 0; i < dustCount; i++) {
      dustPos[i * 3] = (Math.random() - 0.5) * 1200;
      dustPos[i * 3 + 1] = (Math.random() - 0.5) * 600;
      dustPos[i * 3 + 2] = (Math.random() - 0.5) * 2000;
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 2.0,
      transparent: true,
      opacity: 0.6
    });
    const dustSystem = new THREE.Points(dustGeo, dustMat);
    dustSystem.frustumCulled = false;
    scene.add(dustSystem);

    function createPlayerShip() {
      const ship = new THREE.Group();
      ship.userData.parts = {};

      const bodyGeo = new THREE.BoxGeometry(1.0, 0.4, 4.0);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.2,
        metalness: 0.8
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true;
      ship.add(body);
      ship.userData.parts.body = body;

      const noseGeo = new THREE.ConeGeometry(0.5, 2.0, 4);
      noseGeo.rotateX(-Math.PI / 2);
      noseGeo.rotateZ(Math.PI / 4);
      const nose = new THREE.Mesh(noseGeo, bodyMat);
      nose.position.z = -3.0;
      body.add(nose);

      const cockGeo = new THREE.CapsuleGeometry(0.25, 0.6, 4, 8);
      cockGeo.rotateX(-Math.PI / 2);
      const cockpit = new THREE.Mesh(cockGeo, new THREE.MeshStandardMaterial({
        color: 0x00ccff,
        emissive: 0x0088ff,
        emissiveIntensity: 1.0
      }));
      cockpit.position.set(0, 0.3, -1.0);
      cockpit.rotation.x = -0.2;
      body.add(cockpit);

      const wingMat = new THREE.MeshStandardMaterial({
        color: 0x0055aa,
        roughness: 0.2,
        side: THREE.DoubleSide
      });
      const wingShape = new THREE.Shape();
      wingShape.moveTo(0, 0);
      wingShape.lineTo(-3.0, 0);
      wingShape.lineTo(0, 3.0);
      wingShape.lineTo(0, 0);
      const wingGeo = new THREE.ShapeGeometry(wingShape);
      wingGeo.rotateX(-Math.PI / 2);

      const lWingGroup = new THREE.Group();
      lWingGroup.position.set(-0.5, 0, 0.5);
      ship.add(lWingGroup);
      ship.userData.parts.lWing = lWingGroup;
      const lWing = new THREE.Mesh(wingGeo, wingMat);
      lWingGroup.add(lWing);

      const rWingGroup = new THREE.Group();
      rWingGroup.position.set(0.5, 0, 0.5);
      ship.add(rWingGroup);
      ship.userData.parts.rWing = rWingGroup;
      const rWing = new THREE.Mesh(wingGeo, wingMat);
      rWing.scale.x = -1;
      rWingGroup.add(rWing);

      const engMat = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.5
      });
      const lEngGroup = new THREE.Group();
      lEngGroup.position.set(-0.8, -0.2, 0.5);
      ship.add(lEngGroup);
      ship.userData.parts.lEng = lEngGroup;
      const legGeo = new THREE.BoxGeometry(0.8, 0.8, 3.0);
      const lLegMesh = new THREE.Mesh(legGeo, engMat);
      lLegMesh.position.set(0, 0, 1.25);
      lEngGroup.add(lLegMesh);
      const glow = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.6), new THREE.MeshBasicMaterial({
        color: 0x00ffff
      }));
      glow.position.set(0, 0, 1.51);
      lLegMesh.add(glow);

      const rEngGroup = new THREE.Group();
      rEngGroup.position.set(0.8, -0.2, 0.5);
      ship.add(rEngGroup);
      ship.userData.parts.rEng = rEngGroup;
      const rLegMesh = new THREE.Mesh(legGeo, engMat);
      rLegMesh.position.set(0, 0, 1.25);
      rEngGroup.add(rLegMesh);
      const rGlow = glow.clone();
      rLegMesh.add(rGlow);

      const range = 1200;
      const angle = Math.PI / 4;
      const segments = 8;
      const pts = [];
      pts.push(new THREE.Vector3(0, 0, 0));
      for (let i = 0; i <= segments; i++) {
        const th = (i / segments) * angle - angle / 2;
        pts.push(new THREE.Vector3(Math.sin(th) * range, 0, -Math.cos(th) * range));
      }
      pts.push(new THREE.Vector3(0, 0, 0));
      const lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
      const lineMat = new THREE.LineBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.3
      });
      droneSightMesh = new THREE.Line(lineGeo, lineMat);
      droneSightMesh.visible = false;
      droneSightMesh.position.y = -5;
      scene.add(droneSightMesh);

      return ship;
    }
    const player = createPlayerShip();
    scene.add(player);
    const options = [];
    for (let i = 0; i < 2; i++) {
      const opt = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshStandardMaterial({
        color: 0xffaa00,
        emissive: 0xff5500,
        emissiveIntensity: 0.5
      }));
      opt.castShadow = true;
      player.add(opt);
      options.push({
        mesh: opt
      });
      opt.position.set(i === 0 ? -5 : 5, 0, 0);
    }

    function createEnemy() {
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.OctahedronGeometry(3, 0), new THREE.MeshStandardMaterial({
        color: 0xff3300,
        roughness: 0.3,
        metalness: 0.5
      }));
      body.castShadow = true;
      g.add(body);
      const ring = new THREE.Mesh(new THREE.TorusGeometry(4, 0.2, 4, 8), new THREE.MeshBasicMaterial({
        color: 0xffaa00
      }));
      ring.rotation.x = Math.PI / 2;
      g.add(ring);
      g.userData.ring = ring;
      return g;
    }

    let bullets = [],
      missiles = [],
      enemies = [],
      particles = [];

    function spawnExplosion(pos, color = 0xff8800) {
      for (let i = 0; i < 12; i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshBasicMaterial({
          color: color
        }));
        p.position.copy(pos);
        p.scale.setScalar(1.5);
        scene.add(p);
        particles.push({
          mesh: p,
          vel: new THREE.Vector3((Math.random() - 0.5) * 8, Math.random() * 8, (Math.random() - 0.5) * 8),
          life: 1.0
        });
      }
    }

    function spawnDestroyedMarker(x, y) {
      const div = document.createElement('div');
      div.className = 'lock-marker destroyed';
      div.style.left = x + 'px';
      div.style.top = y + 'px';
      document.getElementById('effect-container').appendChild(div);
      setTimeout(() => div.remove(), 400);
    }

    function updateSpeed(delta) {
      if (gameState !== 'PLAY') return;
      gameSpeed += delta;
      if (gameSpeed < CFG.initSpeed) gameSpeed = CFG.initSpeed;
      if (gameSpeed > CFG.maxSpeed) gameSpeed = CFG.maxSpeed;
      document.getElementById('speed-val').innerText = Math.floor(gameSpeed * 200);
      const st = STAGES[currentStageIdx];
      if (st) {
        const pct = Math.min(100, (gameSpeed / st.target) * 100);
        document.getElementById('warp-bar').style.width = pct + '%';
        if (gameSpeed >= st.target) {
          startWarp();
        }
      }
      const speedEl = document.getElementById('speed-row');
      if (gameSpeed > 10.0) speedEl.style.color = '#ff0055';
      else if (gameSpeed > 6.0) speedEl.style.color = '#ffcc00';
      else speedEl.style.color = '#00ff00';
    }

    function takeDamage(amount) {
      if (gameState !== 'PLAY') return;
      currentHP -= amount;
      if (currentHP < 0) currentHP = 0;
      const bar = document.getElementById('hp-bar');
      bar.style.width = currentHP + '%';
      if (currentHP < 30) bar.style.backgroundColor = '#ff0000';
      else if (currentHP < 60) bar.style.backgroundColor = '#ffff00';
      else bar.style.backgroundColor = '#00ff00';
      const overlay = document.getElementById('damage-overlay');
      overlay.style.opacity = 0.5;
      setTimeout(() => {
        overlay.style.opacity = 0;
      }, 100);
      updateSpeed(-CFG.speedDownPerHit);
      if (currentHP === 0) {
        gameSpeed = CFG.initSpeed;
        updateSpeed(0);
        currentHP = CFG.maxHP;
        bar.style.width = '100%';
        bar.style.backgroundColor = '#00ff00';
      }
    }

    function startGame() {
      document.getElementById('title-screen').style.display = 'none';
      document.getElementById('click-catcher').style.display = 'none';
      document.getElementById('ui').style.display = 'block';
      document.getElementById('mobile-controls').style.display = 'block';
      if (!isDroneMode) document.getElementById('hud-reticle').style.display = 'block';
      gameState = 'PLAY';
      startTime = performance.now();
      stageStartTime = startTime;

      // ★追加: ゲーム開始時にステージ1の空に戻し、プレイヤー位置と回転をリセット
      setStageVisuals(0);
      player.position.set(0, 0, 0);
      player.rotation.set(0, 0, 0);
      worldZ = 0;
    }
    document.getElementById('click-catcher').addEventListener('click', () => {
      if (gameState === 'INIT') startGame();
    });

    function startWarp() {
      gameState = 'WARP';
      const msg = document.getElementById('center-msg');
      msg.innerText = "WARP ENGAGED!!";
      msg.style.display = 'block';
      msg.style.color = '#00ffff';
      msg.style.fontSize = '30px';
      document.getElementById('lock-container').innerHTML = '';
      lockedEnemies = [];
      setTimeout(() => {
        currentStageIdx++;
        if (currentStageIdx >= STAGES.length) {
          finishGame();
        } else {
          document.getElementById('stage-name').innerText = STAGES[currentStageIdx].name;
          msg.innerText = STAGES[currentStageIdx].name + " START";

          setStageVisuals(currentStageIdx);

          gameSpeed = CFG.initSpeed * 1.5;
          enemies.forEach(e => disposeObj(e.mesh));
          enemies = [];
          buildings.forEach(b => disposeObj(b));
          buildings = [];
          missiles.forEach(m => {
            disposeObj(m.mesh);
            if (m.trail) disposeObj(m.trail);
          });
          missiles = [];
          bullets.forEach(b => disposeObj(b));
          bullets = [];
          setTimeout(() => {
            msg.style.display = 'none';
            gameState = 'PLAY';
            stageStartTime = performance.now();
          }, 1000);
        }
      }, 1500);
    }

    function finishGame() {
      gameState = 'CLEARED';
      document.getElementById('ui').style.display = 'none';
      document.getElementById('mobile-controls').style.display = 'none';
      document.getElementById('center-msg').style.display = 'none';
      document.getElementById('hud-reticle').style.display = 'none';
      document.getElementById('lock-container').innerHTML = '';
      document.getElementById('result-screen').style.display = 'block';
      document.getElementById('final-time').innerText = formatTime(elapsed);
      loadRanking();
    }

    function formatTime(ms) {
      const m = Math.floor(ms / 60000);
      const s = Math.floor((ms % 60000) / 1000);
      const mil = Math.floor(ms % 1000);
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(mil).padStart(3,'0')}`;
    }

    const SAVE_KEY = 'VP2064_INTEGRATED_RTA';

    function loadRanking() {
      const list = JSON.parse(localStorage.getItem(SAVE_KEY) || '[]');
      list.sort((a, b) => a.ms - b.ms);
      const div = document.getElementById('ranking-content');
      div.innerHTML = '';
      list.slice(0, 5).forEach((d, i) => {
        div.innerHTML += `<div class="rank-row"><span>${i+1}. ${d.name}</span><span>${d.time}</span></div>`;
      });
    }
    document.getElementById('btn-tweet').onclick = () => {
      const n = document.getElementById('pilot-name').value || "PILOT";
      const t = document.getElementById('final-time').innerText;
      const l = JSON.parse(localStorage.getItem(SAVE_KEY) || '[]');
      l.push({
        name: n,
        time: t,
        ms: elapsed
      });
      localStorage.setItem(SAVE_KEY, JSON.stringify(l));
      loadRanking();
      window.open(`https://twitter.com/intent/tweet?text=Cleared VP 2064 (Integrated RTA) in ${t}!&hashtags=VP2064`, '_blank');
    };
    document.getElementById('btn-restart').onclick = () => location.reload();

    const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
    dirLight.position.set(-100, 200, 100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    const d = 600;
    dirLight.shadow.camera.left = -d;
    dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d;
    dirLight.shadow.camera.bottom = -d;
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    const box3A = new THREE.Box3();
    const box3B = new THREE.Box3();

    function checkCollision(meshA, meshB) {
      box3A.setFromObject(meshA);
      box3B.setFromObject(meshB);
      return box3A.intersectsBox(box3B);
    }

    function keepPlayerOnScreen() {
      if (isDroneMode) {
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(vFOV / 2) * 150;
        const visibleWidth = visibleHeight * camera.aspect;
        const centerZ = worldZ - 100;
        const limitZ = visibleHeight * 0.45;
        const limitX = visibleWidth * 0.45;
        player.position.x = Math.max(-limitX, Math.min(limitX, player.position.x));
        player.position.z = Math.max(centerZ - limitZ, Math.min(centerZ + limitZ, player.position.z));
      } else {
        const dist = 80;
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
        const visibleWidth = visibleHeight * camera.aspect;

        const camY = camera.position.y;
        const camX = camera.position.x;

        const topEdge = camY + visibleHeight * 0.45;
        const bottomEdge = camY - visibleHeight * 0.45;
        const rightEdge = camX + visibleWidth * 0.45;
        const leftEdge = camX - visibleWidth * 0.45;

        player.position.x = Math.max(leftEdge, Math.min(rightEdge, player.position.x));
        player.position.y = Math.max(bottomEdge, Math.min(topEdge, player.position.y));

        player.position.y = Math.max(-100, Math.min(300, player.position.y));
        player.position.x = Math.max(-600, Math.min(600, player.position.x));
      }
    }

    function toScreenPosition(obj, camera) {
      const vector = new THREE.Vector3();
      obj.updateMatrixWorld();
      vector.setFromMatrixPosition(obj.matrixWorld);
      vector.project(camera);
      const widthHalf = 0.5 * window.innerWidth;
      const heightHalf = 0.5 * window.innerHeight;
      return {
        x: (vector.x * widthHalf) + widthHalf,
        y: -(vector.y * heightHalf) + heightHalf,
        z: vector.z
      };
    }

    // ★追加: 初期化処理
    function initGame() {
      setTitleVisuals(); // タイトル画面の宇宙背景を設定
      // プレイヤーを画面中央付近に配置
      player.position.set(0, 20, -50);
    }
    initGame();

    function animate() {
      requestAnimationFrame(animate);
      frame++;

      // ★追加: タイトル画面での機体のアイドリングモーション
      if (gameState === 'INIT') {
        player.rotation.z = Math.sin(frame * 0.02) * 0.1;
        player.rotation.x = Math.cos(frame * 0.02) * 0.05;
        player.position.y = 20 + Math.sin(frame * 0.05) * 2;
        composer.render();
        return;
      }

      if (gameState === 'CLEARED') {
        composer.render();
        return;
      }

      const now = performance.now();
      elapsed = now - startTime;
      document.getElementById('timer').innerText = formatTime(elapsed);

      const spd = (gameState === 'WARP') ? CFG.maxSpeed * 3 : gameSpeed;
      worldZ -= spd;

      sea.position.z = camera.position.z;

      const parts = player.userData.parts;
      if (parts) {
        if (isDroneMode) {
          parts.lEng.rotation.x = MathUtils.lerp(parts.lEng.rotation.x, Math.PI / 2 + 0.2, 0.1);
          parts.rEng.rotation.x = MathUtils.lerp(parts.rEng.rotation.x, Math.PI / 2 + 0.2, 0.1);
          parts.lWing.rotation.z = MathUtils.lerp(parts.lWing.rotation.z, -0.5, 0.1);
          parts.rWing.rotation.z = MathUtils.lerp(parts.rWing.rotation.z, 0.5, 0.1);
          parts.body.rotation.x = MathUtils.lerp(parts.body.rotation.x, 0.3, 0.1);
        } else {
          parts.lEng.rotation.x = MathUtils.lerp(parts.lEng.rotation.x, 0, 0.1);
          parts.rEng.rotation.x = MathUtils.lerp(parts.rEng.rotation.x, 0, 0.1);
          parts.lWing.rotation.z = MathUtils.lerp(parts.lWing.rotation.z, 0, 0.1);
          parts.rWing.rotation.z = MathUtils.lerp(parts.rWing.rotation.z, 0, 0.1);
          parts.body.rotation.x = MathUtils.lerp(parts.body.rotation.x, 0, 0.1);
        }
      }

      if (isInspectMode) {
        camera.up.set(0, 1, 0);
        const targetX = player.position.x + 10;
        const targetY = player.position.y + 5;
        const targetZ = player.position.z - 15;
        camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.1);
        camera.lookAt(player.position);
      } else {
        if (isDroneMode) {
          camera.up.set(0, 0, -1);
          const camTargetZ = worldZ + 50;
          camera.position.x += (0 - camera.position.x) * 0.1;
          camera.position.z += (camTargetZ - camera.position.z) * 0.1;
          camera.position.y += (150 - camera.position.y) * 0.1;
          camera.lookAt(camera.position.x, 0, worldZ - 100);
        } else {
          camera.up.set(0, 1, 0);
          const targetFov = baseFov + (gameSpeed - CFG.initSpeed) * 2.0;
          camera.fov += (targetFov - camera.fov) * 0.05;
          camera.updateProjectionMatrix();
          camera.position.x += (player.position.x * 0.6 - camera.position.x) * 0.05;
          camera.position.y += (player.position.y * 0.6 + 20 - camera.position.y) * 0.05;
          camera.position.z = worldZ + 80;
          camera.lookAt(player.position.x * 0.5, player.position.y * 0.5, player.position.z - 100);
        }
      }

      dirLight.position.z = worldZ + 100;
      dirLight.target.position.z = worldZ - 100;
      dirLight.target.updateMatrixWorld();

      if (gameState === 'PLAY') {
        let targetDX = 0;
        let targetDY = 0;
        if (isDroneMode) {
          if (joyInput.x !== 0 || joyInput.y !== 0) {
            targetDX = joyInput.x * CFG.playerMoveSpeed;
            targetDY = -joyInput.y * CFG.playerMoveSpeed;
          } else {
            if (keys.ArrowLeft) targetDX = -CFG.playerMoveSpeed;
            if (keys.ArrowRight) targetDX = CFG.playerMoveSpeed;
            if (keys.ArrowUp) targetDY = -CFG.playerMoveSpeed;
            if (keys.ArrowDown) targetDY = CFG.playerMoveSpeed;
          }
          player.position.z -= spd;
          player.position.x += targetDX;
          player.position.z += targetDY * 2.0;
          player.position.y += (0 - player.position.y) * 0.1;

        } else {
          if (joyInput.x !== 0 || joyInput.y !== 0) {
            targetDX = joyInput.x * CFG.playerMoveSpeed;
            targetDY = -joyInput.y * CFG.playerMoveSpeed;
          } else {
            if (keys.ArrowLeft) targetDX = -CFG.playerMoveSpeed;
            if (keys.ArrowRight) targetDX = CFG.playerMoveSpeed;
            if (keys.ArrowUp) targetDY = CFG.playerMoveSpeed;
            if (keys.ArrowDown) targetDY = -CFG.playerMoveSpeed;
          }
          player.position.x += targetDX;
          player.position.y += targetDY;
          player.position.z = worldZ;
        }

        keepPlayerOnScreen();

        const targetRoll = -targetDX * 0.5;
        const targetPitch = isDroneMode ? 0 : targetDY * 0.2;
        player.rotation.z += (targetRoll - player.rotation.z) * 0.1;
        player.rotation.x += (targetPitch - player.rotation.x) * 0.1;

        if (droneSightMesh) {
          droneSightMesh.position.copy(player.position);
          droneSightMesh.position.y -= 10;
        }

      } else {
        player.position.z = worldZ;
      }
      options[0].mesh.position.y = Math.sin(frame * 0.1) * 1.0;
      options[1].mesh.position.y = Math.cos(frame * 0.1) * 1.0;

      if (gameState === 'PLAY') {
        const reticle = document.getElementById('hud-reticle');
        const aimTarget = player.position.clone();
        aimTarget.z -= 500;
        const vec = aimTarget.clone().project(camera);
        const rx = (vec.x * 0.5 + 0.5) * window.innerWidth;
        const ry = (-(vec.y * 0.5) + 0.5) * window.innerHeight;
        reticle.style.left = rx + 'px';
        reticle.style.top = ry + 'px';

        const lockContainer = document.getElementById('lock-container');
        lockContainer.innerHTML = '';
        lockedEnemies = [];
        let bestTarget = null;
        let minScreenDist = 9999;

        if (isDroneMode) {
          const pureForward = new THREE.Vector3(0, 0, -1);
          const range = 1200;
          const angleLimit = Math.cos(Math.PI / 8);

          enemies.forEach(e => {
            if (e.mesh.position.z < player.position.z) {
              const vecToEnemy = new THREE.Vector3().subVectors(e.mesh.position, player.position);
              const dist = vecToEnemy.length();

              if (dist < range) {
                vecToEnemy.normalize();
                const angle = pureForward.dot(vecToEnemy);
                if (angle > angleLimit) {
                  lockedEnemies.push(e.mesh);
                  const sPos = toScreenPosition(e.mesh, camera);
                  if (sPos.z < 1) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'lock-wrapper';
                    wrapper.style.left = sPos.x + 'px';
                    wrapper.style.top = sPos.y + 'px';
                    wrapper.innerHTML = `<div class="lock-bracket"></div><div class="lock-info"><span class="lock-label">LOCK</span><span>${Math.floor(dist)}m</span></div>`;
                    lockContainer.appendChild(wrapper);
                  }
                  if (dist < minScreenDist) {
                    minScreenDist = dist;
                    bestTarget = e.mesh;
                  }
                }
              }
            }
          });

        } else {
          let minDistHUD = 100;
          enemies.forEach(e => {
            if (e.mesh.position.z < player.position.z) {
              const dist = player.position.distanceTo(e.mesh.position);
              if (dist < 1800) {
                const sPos = toScreenPosition(e.mesh, camera);
                if (sPos.z < 1) {
                  const dx = sPos.x - rx;
                  const dy = sPos.y - ry;
                  const d = Math.sqrt(dx * dx + dy * dy);
                  if (d < 100) {
                    lockedEnemies.push(e.mesh);
                    const wrapper = document.createElement('div');
                    wrapper.className = 'lock-wrapper';
                    wrapper.style.left = sPos.x + 'px';
                    wrapper.style.top = sPos.y + 'px';
                    wrapper.innerHTML = `<div class="lock-bracket"></div><div class="lock-info"><span class="lock-label">LOCK</span><span>${Math.floor(dist)}m</span></div>`;
                    lockContainer.appendChild(wrapper);
                    if (d < minDistHUD) {
                      minDistHUD = d;
                      bestTarget = e.mesh;
                    }
                  }
                }
              }
            }
          });
        }

        const stageTime = performance.now() - stageStartTime;
        let spawnInterval = Math.max(2, Math.floor(10 / (gameSpeed / 4)));
        if (stageTime > DENSITY_SETTINGS.reductionStart) {
          const extra = Math.floor((stageTime - DENSITY_SETTINGS.reductionStart) / 1000 * DENSITY_SETTINGS.reductionStrength);
          spawnInterval += extra;
        }
        if (frame % spawnInterval === 0) {
          const spawnZ = worldZ - 1500 - (gameSpeed * 50);
          const x = (Math.random() - 0.5) * 1000;
          const b = createBuilding(x, spawnZ);
          buildings.push(b);
        }

        if (!keys[" "] && frame % 5 === 0) {
          [0, -4, 4].forEach(o => {
            const b = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 8), new THREE.MeshBasicMaterial({
              color: 0x00ffff
            }));
            b.position.set(player.position.x + o, player.position.y, player.position.z - 3);
            scene.add(b);
            bullets.push(b);
          });
        }

        if (!keys.z && frame % 20 === 0) {
          const beamLen = 200.0;
          const mGeo = new THREE.CylinderGeometry(0.1, 0.01, beamLen, 2);
          mGeo.rotateX(Math.PI / 2);
          mGeo.translate(0, 0, -beamLen / 2);
          const mMat = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffaa00,
            emissiveIntensity: 5.0,
            roughness: 0.0,
            metalness: 0.0
          });
          const m = new THREE.Mesh(mGeo, mMat);
          m.position.copy(player.position);
          scene.add(m);
          missiles.push({
            mesh: m,
            vel: new THREE.Vector3(0, 0, -1),
            target: bestTarget,
            speed: 2.0
          });
        }
      }

      for (let i = buildings.length - 1; i >= 0; i--) {
        const b = buildings[i];
        if (gameState === 'PLAY' && Math.abs(b.position.z - player.position.z) < 30 && checkCollision(player, b)) {
          takeDamage(15);
          spawnExplosion(player.position, 0xaaaaaa);
          disposeObj(b);
          buildings.splice(i, 1);
          continue;
        }
        if (b.position.z > worldZ + 200) {
          disposeObj(b);
          buildings.splice(i, 1);
        }
      }

      const dPos = dustSystem.geometry.attributes.position.array;
      for (let i = 0; i < dustCount; i++) {
        let z = dPos[i * 3 + 2];
        if (z > worldZ + 50) {
          z = worldZ - 1500 - Math.random() * 500;
          dPos[i * 3] = (Math.random() - 0.5) * 1200;
          dPos[i * 3 + 1] = (Math.random() - 0.5) * 600;
        }
        dPos[i * 3 + 2] = z;
      }
      dustSystem.geometry.attributes.position.needsUpdate = true;

      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].position.z -= (gameSpeed + CFG.shotSpeed);
        if (bullets[i].position.z < worldZ - 1200) {
          disposeObj(bullets[i]);
          bullets.splice(i, 1);
        }
      }

      for (let i = missiles.length - 1; i >= 0; i--) {
        let m = missiles[i];
        m.speed = Math.min(m.speed + 0.1, CFG.missileSpeed);
        if (m.target && m.target.parent) {
          m.vel.lerp(new THREE.Vector3().subVectors(m.target.position, m.mesh.position).normalize(), 0.15);
        } else {
          m.vel.z = -1;
        }
        m.mesh.position.add(m.vel.clone().normalize().multiplyScalar(gameSpeed + m.speed));
        m.mesh.lookAt(m.mesh.position.clone().add(m.vel));
        if (frame % 2 === 0) {
          const p = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshBasicMaterial({
            color: 0x888888
          }));
          p.position.copy(m.mesh.position);
          scene.add(p);
          particles.push({
            mesh: p,
            vel: new THREE.Vector3(0, 0, 0),
            life: 0.3
          });
        }
        if (m.mesh.position.z < worldZ - 1200) {
          disposeObj(m.mesh);
          missiles.splice(i, 1);
        }
      }

      if (gameState === 'PLAY') {
        const enemySpawnRate = Math.max(10, Math.floor(40 - gameSpeed));
        if (frame % enemySpawnRate === 0) {
          const e = createEnemy();
          e.position.set((Math.random() - 0.5) * 400, (Math.random() - 0.5) * 200, worldZ - 1200);
          scene.add(e);
          enemies.push({
            mesh: e
          });
        }
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.mesh.rotation.y += 0.02;
        if (e.mesh.userData.ring) e.mesh.userData.ring.rotation.z += 0.1;
        if (gameState === 'PLAY' && checkCollision(player, e.mesh)) {
          takeDamage(20);
          spawnExplosion(e.mesh.position, 0xff0000);
          disposeObj(e.mesh);
          enemies.splice(i, 1);
          continue;
        }

        let hit = false;
        for (let j = bullets.length - 1; j >= 0; j--) {
          if (!hit && e.mesh.position.distanceTo(bullets[j].position) < 8) {
            disposeObj(bullets[j]);
            bullets.splice(j, 1);
            hit = true;
          }
        }
        if (!hit) {
          for (let j = missiles.length - 1; j >= 0; j--) {
            if (!hit && checkCollision(missiles[j].mesh, e.mesh)) {
              disposeObj(missiles[j].mesh);
              missiles.splice(j, 1);
              hit = true;
            }
          }
        }

        if (hit) {
          updateSpeed(CFG.speedUpPerKill);
          spawnExplosion(e.mesh.position);
          if (lockedEnemies.includes(e.mesh)) {
            const sPos = toScreenPosition(e.mesh, camera);
            if (sPos.z < 1) spawnDestroyedMarker(sPos.x, sPos.y);
          }
          disposeObj(e.mesh);
          enemies.splice(i, 1);
          score += 500;
          document.getElementById('score').innerText = score;
        } else if (e.mesh.position.z > worldZ + 50) {
          disposeObj(e.mesh);
          enemies.splice(i, 1);
        }
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.mesh.position.add(p.vel);
        p.life -= 0.05;
        p.mesh.scale.setScalar(p.life);
        if (p.life <= 0) {
          disposeObj(p.mesh);
          particles.splice(i, 1);
        }
      }

      composer.render();
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
  </script>
</body>

</html>