<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>キャラクターヒットボックスエディタ v22.0 (座標系統一版)</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.min.js"></script>
    <style>
      :root {
        --bg-color: #333;
        --panel-bg: #444;
        --text-color: #f0f0f0;
        --border-color: #555;
        --accent-color: #00aaff;
        --hitbox-fill: rgba(255, 0, 0, 0.4);
        --hitbox-stroke: rgba(255, 0, 0, 0.9);
        --selected-stroke: rgba(255, 255, 0, 0.9);
        --guide-stroke: rgba(255, 255, 0, 0.6);
      }
      body {
        font-family: 'Segoe UI', sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }
      .container {
        display: grid;
        grid-template-columns: 1fr 400px;
        gap: 15px;
        padding: 15px;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }
      .panel {
        background-color: var(--panel-bg);
        border-radius: 8px;
        padding: 0;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }
      .panel-content {
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        flex-grow: 1;
      }
      .canvas-container {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: var(--panel-bg);
        border-radius: 8px;
        overflow: hidden;
      }
      .canvas-container canvas {
        position: absolute;
      }
      #webgl-canvas {
        background-color: #282828;
      }
      #editorCanvas {
        background-color: transparent;
        z-index: 10;
        cursor: default;
      }
      .bg-grid {
        background-image: linear-gradient(45deg, #3a3a3a 25%, transparent 25%), linear-gradient(-45deg, #3a3a3a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #3a3a3a 75%), linear-gradient(-45deg, transparent 75%, #3a3a3a 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      }
      h3 {
        margin-top: 0;
        color: var(--accent-color);
        border-bottom: 2px solid var(--border-color);
        padding-bottom: 8px;
      }
      button {
        background-color: var(--accent-color);
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        transition: background-color 0.2s;
        width: 100%;
        box-sizing: border-box;
      }
      button:hover:not(:disabled) {
        background-color: #0088cc;
      }
      button:disabled {
        background-color: #555;
        cursor: not-allowed;
      }
      button.active {
        background-color: #e67e22;
      }
      input[type='file'] {
        display: none;
      }
      .file-label {
        background-color: #5a5a5a;
        color: white;
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        text-align: center;
        display: block;
      }
      .file-label:hover {
        background-color: #6a6a6a;
      }
      .property-grid {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
        align-items: center;
      }
      input[type='number'],
      input[type='text'] {
        width: 100%;
        padding: 8px;
        background-color: #333;
        border: 1px solid var(--border-color);
        color: var(--text-color);
        border-radius: 4px;
        box-sizing: border-box;
      }
      textarea {
        width: 100%;
        min-height: 80px;
        background-color: #222;
        border: 1px solid var(--border-color);
        color: #ddd;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.9em;
        padding: 10px;
        border-radius: 4px;
        resize: vertical;
        box-sizing: border-box;
      }
      fieldset {
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 15px;
        margin: 0;
      }
      legend {
        padding: 0 10px;
        color: var(--accent-color);
        font-weight: bold;
      }
      .button-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .button-row {
        display: flex;
        gap: 10px;
      }
      .slider-group {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }
      .mode-switcher {
        display: flex;
        background-color: #3a3a3a;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
      }
      .mode-button {
        flex: 1;
        padding: 15px;
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 1.1em;
        cursor: pointer;
        border-bottom: 4px solid transparent;
        transition: background-color 0.2s, border-color 0.2s;
      }
      .mode-button:hover {
        background-color: #4f4f4f;
      }
      .mode-button.active {
        color: var(--accent-color);
        border-bottom-color: var(--accent-color);
        background-color: var(--panel-bg);
      }
      .mode-panel {
        display: none;
      }
      .mode-panel.active {
        display: block;
      }
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .modal-content {
        background: var(--panel-bg);
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        max-width: 500px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }
      .slot-list {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      #selection-box {
        position: absolute;
        border: 1px solid #55aaff;
        background-color: rgba(85, 170, 255, 0.3);
        z-index: 100;
        pointer-events: none;
        display: none;
      }
      .slider-wrapper {
        position: relative;
        flex-grow: 1;
        display: flex;
        align-items: center;
      }
      .slider-wrapper input[type='range'] {
        width: 100%;
      }
      #rotationYTooltip {
        position: absolute;
        display: none;
        background-color: #555;
        color: white;
        font-weight: bold;
        padding: 5px 10px;
        border-radius: 5px;
        bottom: 35px;
        left: 50%;
        transform: translateX(-50%);
        white-space: nowrap;
        pointer-events: none;
      }
      #rotationYTooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 6px solid transparent;
        border-top-color: #555;
      }
    </style>
  </head>
  <body>
    <div id="selection-box"></div>
    <div class="container">
      <div class="canvas-container" id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
        <canvas id="editorCanvas"></canvas>
      </div>

      <div class="panel">
        <div class="mode-switcher">
          <button id="assetModeBtn" class="mode-button active">アセット</button>
          <button id="hitboxModeBtn" class="mode-button">ヒットボックス</button>
        </div>

        <div class="panel-content">
          <div id="assetModePanel" class="mode-panel active">
            <fieldset>
              <h3>プロジェクト</h3>
              <button id="openSaveLoadModalBtn">状態のセーブ / ロード</button>
            </fieldset>
            <fieldset>
              <h3>アセット読み込み</h3>
              <div class="button-group">
                <input type="file" id="imageLoader" accept="image/png, image/gif" multiple />
                <label for="imageLoader" class="file-label">画像スプライト</label>
                <input type="file" id="mecJsonLoader" accept=".json" />
                <label for="mecJsonLoader" class="file-label" style="background-color: #27ae60">MEC JSON モデル</label>
                <button id="deleteAssetBtn" disabled>アセットをクリア</button>
              </div>
            </fieldset>

            <fieldset id="modelControls" style="display: none">
              <h3>モデル操作</h3>
              <div class="slider-container">
                <div class="slider-group">
                  <span>回転 Y:</span>
                  <div class="slider-wrapper">
                    <input type="range" id="rotationY" min="-180" max="180" value="0" step="45" />
                    <div id="rotationYTooltip"></div>
                  </div>
                </div>
              </div>
              <div class="slider-group"><span>回転 X:</span> <input type="range" id="rotationX" min="-180" max="180" value="0" style="flex-grow: 1" /></div>
            </fieldset>
            <fieldset>
              <h3>基準座標ガイド</h3>
              <p style="font-size: 0.8em; color: #ccc; margin-top: 0">3Dモデルのサイズ基準となるガイドを表示します。</p>
              <div class="button-row">
                <button id="guidePlayerBtn">自機</button>
                <button id="guideZakoBtn">ザコ</button>
                <button id="guideBossBtn">ボス</button>
              </div>
              <button id="guideClearBtn" style="margin-top: 10px; background-color: #7f8c8d">ガイド消去</button>
            </fieldset>
          </div>

          <div id="hitboxModePanel" class="mode-panel">
            <fieldset>
              <h3>ヒットボックス編集</h3>
              <div class="button-group">
                <button id="addHitboxBtn">ヒットボックスを追加</button>
                <button id="deleteHitboxBtn" disabled>選択中を削除</button>
              </div>
              <div id="propertiesPanel" style="margin-top: 15px; display: none">
                <div class="property-grid">
                  <label for="propOffsetX">offsetX</label> <input type="number" id="propOffsetX" step="0.01" /> <label for="propOffsetY">offsetY</label> <input type="number" id="propOffsetY" step="0.01" /> <label for="propWidth">width</label> <input type="number" id="propWidth" step="0.01" /> <label for="propHeight">height</label>
                  <input type="number" id="propHeight" step="0.01" />
                </div>
              </div>
            </fieldset>
            <fieldset>
              <h3>テンプレート</h3>
              <div class="property-grid" style="margin-bottom: 10px">
                <label for="hitboxTemplateName">テンプレート名:</label>
                <input type="text" id="hitboxTemplateName" placeholder="例: player_hitbox" />
              </div>
              <button id="saveHitboxTemplateBtn">現在のヒットボックス群を保存</button>
              <div id="hitboxTemplateList" style="margin-top: 10px"></div>
            </fieldset>
            <fieldset>
              <h3>エクスポート</h3>
              <button id="exportFighterJsonBtn" disabled>ヒットボックスとMecモデルをJSONで書き出し</button>
              <button id="exportBtn" disabled>スプライトを切り出して保存</button>
              <textarea id="jsonOutput" readonly></textarea>
              <button id="copyJsonBtn">JSONをコピー</button>
            </fieldset>
          </div>
        </div>
      </div>
    </div>

    <div id="saveLoadModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>状態のセーブ / ロード</h3>
        <div class="slot-list"></div>
        <button id="closeModalBtn" style="margin-top: 20px; background-color: #777">閉じる</button>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const editorCanvas = document.getElementById('editorCanvas');
        const webglCanvas = document.getElementById('webgl-canvas');
        const ctx = editorCanvas.getContext('2d');
        const imageLoader = document.getElementById('imageLoader');
        const mecJsonLoader = document.getElementById('mecJsonLoader');
        const deleteAssetBtn = document.getElementById('deleteAssetBtn');
        const modelControls = document.getElementById('modelControls');
        const rotationYSlider = document.getElementById('rotationY');
        const rotationXSlider = document.getElementById('rotationX');
        const addHitboxBtn = document.getElementById('addHitboxBtn');
        const deleteHitboxBtn = document.getElementById('deleteHitboxBtn');
        const propertiesPanel = document.getElementById('propertiesPanel');
        const propInputs = {offsetX: document.getElementById('propOffsetX'), offsetY: document.getElementById('propOffsetY'), width: document.getElementById('propWidth'), height: document.getElementById('propHeight')};
        const hitboxTemplateNameInput = document.getElementById('hitboxTemplateName');
        const saveHitboxTemplateBtn = document.getElementById('saveHitboxTemplateBtn');
        const hitboxTemplateList = document.getElementById('hitboxTemplateList');
        const exportBtn = document.getElementById('exportBtn');
        const jsonOutput = document.getElementById('jsonOutput');
        const copyJsonBtn = document.getElementById('copyJsonBtn');
        const exportFighterJsonBtn = document.getElementById('exportFighterJsonBtn');
        const assetModeBtn = document.getElementById('assetModeBtn');
        const hitboxModeBtn = document.getElementById('hitboxModeBtn');
        const assetModePanel = document.getElementById('assetModePanel');
        const hitboxModePanel = document.getElementById('hitboxModePanel');
        const guidePlayerBtn = document.getElementById('guidePlayerBtn');
        const guideZakoBtn = document.getElementById('guideZakoBtn');
        const guideBossBtn = document.getElementById('guideBossBtn');
        const guideClearBtn = document.getElementById('guideClearBtn');
        const openSaveLoadModalBtn = document.getElementById('openSaveLoadModalBtn');
        const saveLoadModal = document.getElementById('saveLoadModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const selectionBoxElement = document.getElementById('selection-box');
        const rotationYTooltip = document.getElementById('rotationYTooltip');

        // --- State ---
        let asset = null;
        let hitboxes = [];
        let selectedHitboxes = [];
        let guideDef = null;

        // --- 3D Scene ---
        let scene, camera, renderer, mechaGroup, gridHelper;

        // --- Input Handling State ---
        let isSpacebarDown = false;
        let isPanning = false;
        let panStart = {x: 0, y: 0};
        let cameraStartPos = new THREE.Vector3();
        let isBoxSelecting = false;
        let selectionStartPoint = new THREE.Vector2();
        let dragTarget = null;
        let isResizing = false;
        let resizeHandle = null;
        const dragContext = {
          startMousePos: {x: 0, y: 0},
          initialStates: new Map(),
        };

        // --- Coordinate System ---
        const WORLD_VIEW_HEIGHT = 4.0;
        const Y_OFFSET = 1.5;
        let WORLD_VIEW_WIDTH, PIXELS_PER_UNIT;
        const GRID_CELL_SIZE = 0.1;
        const STORAGE_KEYS = {STATE_PREFIX: 'editor_state_slot_', HITBOX_TEMPLATES: 'editor_hitbox_templates'};
        const GUIDE_DEFINITIONS = {
          player: {w: 1.5, h: 1.0},
          zako: {w: 0.5, h: 0.5},
          boss: {w: 3.0, h: 3.0},
        };

        // --- Core Functions ---
        function onResize() {
          const rect = webglCanvas.parentElement.getBoundingClientRect();
          const fixedAspect = 4 / 3;
          let newWidth = rect.width;
          let newHeight = rect.width / fixedAspect;
          if (newHeight > rect.height) {
            newHeight = rect.height;
            newWidth = newHeight * fixedAspect;
          }
          const resW = Math.round(newWidth),
            resH = Math.round(newHeight);
          [webglCanvas, editorCanvas].forEach((c) => {
            c.style.width = newWidth + 'px';
            c.style.height = newHeight + 'px';
            c.width = resW;
            c.height = resH;
          });
          WORLD_VIEW_WIDTH = WORLD_VIEW_HEIGHT * (resW / resH);
          PIXELS_PER_UNIT = resH / WORLD_VIEW_HEIGHT;
          if (camera) {
            camera.left = -WORLD_VIEW_WIDTH / 2;
            camera.right = WORLD_VIEW_WIDTH / 2;
            camera.top = WORLD_VIEW_HEIGHT / 2;
            camera.bottom = -WORLD_VIEW_HEIGHT / 2;
            camera.updateProjectionMatrix();
          }
          if (renderer) renderer.setSize(resW, resH);
        }

        function worldToScreen(worldPos) {
          const worldPoint = new THREE.Vector3(worldPos.x, worldPos.y, 0);
          const screenPoint = worldPoint.project(camera);
          const x = (screenPoint.x * 0.5 + 0.5) * editorCanvas.width;
          const y = (-screenPoint.y * 0.5 + 0.5) * editorCanvas.height;
          return {x, y};
        }

        function screenToWorld(screenPos) {
          const ndc = new THREE.Vector3((screenPos.x / editorCanvas.width) * 2 - 1, -(screenPos.y / editorCanvas.height) * 2 + 1, 0);
          ndc.unproject(camera);
          return {x: ndc.x, y: ndc.y};
        }

        function updateRotationTooltip() {
          const slider = rotationYSlider;
          const tooltip = rotationYTooltip;

          const min = parseFloat(slider.min);
          const max = parseFloat(slider.max);
          const val = parseFloat(slider.value);

          let labelText = '';
          switch (val) {
            case 0:
              labelText = '正面';
              break;
            case -90:
              labelText = '側面';
              break;
            case 90:
              labelText = '逆側面';
              break;
            case 180:
            case -180:
              labelText = '背面';
              break;
            default:
              labelText = val;
          }
          tooltip.textContent = labelText;

          const percent = (val - min) / (max - min);
          const sliderWidth = slider.offsetWidth;

          const thumbWidth = 16;
          const trackWidth = sliderWidth - thumbWidth;
          const newLeft = percent * trackWidth + thumbWidth / 2;

          tooltip.style.left = `${newLeft}px`;
          tooltip.style.display = 'block';
        }
        function init() {
          renderer = new THREE.WebGLRenderer({canvas: webglCanvas, antialias: true, alpha: true});
          renderer.setClearColor(0x000000, 0);
          renderer.setPixelRatio(window.devicePixelRatio);
          scene = new THREE.Scene();
          camera = new THREE.OrthographicCamera();
          camera.position.set(0, Y_OFFSET, 10);
          camera.lookAt(0, Y_OFFSET, 0);

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
          scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
          directionalLight.position.set(5, 10, 7.5);
          scene.add(directionalLight);

          gridHelper = new THREE.GridHelper(20, 20 / GRID_CELL_SIZE, 0x666666, 0x444444);
          gridHelper.rotation.x = Math.PI / 2;
          gridHelper.visible = true;
          gridHelper.material.depthTest = false;
          gridHelper.renderOrder = -1;
          scene.add(gridHelper);

          mechaGroup = new THREE.Group();
          scene.add(mechaGroup);

          onResize();
          window.addEventListener('resize', onResize);
          window.addEventListener('keydown', onKeyDown);
          window.addEventListener('keyup', onKeyUp);
          editorCanvas.addEventListener('mousedown', onPointerDown);
          editorCanvas.addEventListener('mousemove', onPointerMove);
          editorCanvas.addEventListener('mouseup', onPointerUp);
          editorCanvas.addEventListener('mouseleave', onPointerUp);

          renderLoop();
        }

        function renderLoop() {
          renderer.render(scene, camera);
          ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);

          if (asset && asset.type === 'sprite' && asset.image.complete) {
            const x = (editorCanvas.width - asset.image.width) / 2;
            const y = (editorCanvas.height - asset.image.height) / 2;
            ctx.drawImage(asset.image, x, y, asset.image.width, asset.image.height);
          }

          if (guideDef) {
            const screenPos = worldToScreen({x: -guideDef.w / 2, y: guideDef.h});
            const screenW = guideDef.w * PIXELS_PER_UNIT;
            const screenH = guideDef.h * PIXELS_PER_UNIT;

            ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(screenPos.x, screenPos.y, screenW, screenH);
            ctx.setLineDash([]);
          }

          hitboxes.forEach((box) => {
            const screenPos = worldToScreen({x: box.worldX, y: box.worldY + box.worldH});
            const screenW = box.worldW * PIXELS_PER_UNIT;
            const screenH = box.worldH * PIXELS_PER_UNIT;

            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.lineWidth = 1;
            if (selectedHitboxes.includes(box)) {
              ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
              ctx.lineWidth = 2;
            }
            ctx.fillRect(screenPos.x, screenPos.y, screenW, screenH);
            ctx.strokeRect(screenPos.x, screenPos.y, screenW, screenH);
            if (selectedHitboxes.length === 1 && selectedHitboxes[0] === box) {
              drawResizeHandles(box);
            }
          });
          requestAnimationFrame(renderLoop);
        }

        function drawResizeHandles(box) {
          ctx.fillStyle = 'rgba(255, 80, 80, 0.9)';
          const halfHandle = 4;
          const positions = getResizeHandlePositions(box);
          for (const handle in positions) {
            ctx.fillRect(positions[handle].x - halfHandle, positions[handle].y - halfHandle, halfHandle * 2, halfHandle * 2);
          }
        }

        function onKeyDown(e) {
          if (e.key === ' ' && !isSpacebarDown) {
            e.preventDefault();
            isSpacebarDown = true;
            editorCanvas.style.cursor = 'grab';
          }
        }
        function onKeyUp(e) {
          if (e.key === ' ') {
            isSpacebarDown = false;
            if (!isPanning) updateCursor(getMousePos(e));
          }
        }

        function onPointerDown(e) {
          const pos = getMousePos(e);
          selectionStartPoint.set(e.clientX, e.clientY);
          if (isSpacebarDown) {
            isPanning = true;
            const pos = getMousePos(e);
            panStart.x = pos.x;
            panStart.y = pos.y;
            cameraStartPos.copy(camera.position);
            editorCanvas.style.cursor = 'grabbing';
            return;
          }
          dragTarget = null;
          isResizing = false;
          const clickedBox = getHitboxAt(pos.x, pos.y);

          if (selectedHitboxes.length === 1) {
            resizeHandle = getResizeHandleAt(pos.x, pos.y, selectedHitboxes[0]);
            if (resizeHandle) {
              isResizing = true;
              dragTarget = selectedHitboxes;
            }
          }

          if (!isResizing) {
            if (clickedBox) {
              if (e.ctrlKey) {
                setSelection([clickedBox], true, false);
              } else if (e.shiftKey) {
                setSelection([clickedBox], false, true);
              } else if (!selectedHitboxes.includes(clickedBox)) {
                setSelection([clickedBox], false, false);
              }
              dragTarget = selectedHitboxes;
            } else {
              if (!e.ctrlKey && !e.shiftKey) setSelection([]);
              isBoxSelecting = true;
              Object.assign(selectionBoxElement.style, {left: `${e.clientX}px`, top: `${e.clientY}px`, width: '0px', height: '0px', display: 'block'});
            }
          }

          if (dragTarget && dragTarget.length > 0) {
            dragContext.startMousePos = screenToWorld(pos);
            dragContext.initialStates.clear();
            dragTarget.forEach((box) => {
              dragContext.initialStates.set(box, {...box});
            });
          }
        }

        function onPointerMove(e) {
          const pos = getMousePos(e);
          if (isPanning) {
            const currentWorldPos = screenToWorld(pos);
            const startWorldPos = screenToWorld(panStart);
            camera.position.x = cameraStartPos.x - (currentWorldPos.x - startWorldPos.x);
            camera.position.y = cameraStartPos.y - (currentWorldPos.y - startWorldPos.y);
            return;
          }
          if (isBoxSelecting) {
            const left = Math.min(selectionStartPoint.x, e.clientX);
            const top = Math.min(selectionStartPoint.y, e.clientY);
            const width = Math.abs(selectionStartPoint.x - e.clientX);
            const height = Math.abs(selectionStartPoint.y - e.clientY);
            Object.assign(selectionBoxElement.style, {left: `${left}px`, top: `${top}px`, width: `${width}px`, height: `${height}px`});
            return;
          }

          if (dragTarget) {
            const worldPos = screenToWorld(pos);
            let dx_world = worldPos.x - dragContext.startMousePos.x;
            let dy_world = worldPos.y - dragContext.startMousePos.y;

            if (isResizing) {
              const box = dragTarget[0];
              const initialState = dragContext.initialStates.get(box);
              resizeTarget(box, initialState, dx_world, dy_world, e.ctrlKey);
            } else {
              if (e.shiftKey) {
                if (Math.abs(dx_world) > Math.abs(dy_world)) {
                  dy_world = 0;
                } else {
                  dx_world = 0;
                }
              }

              dragTarget.forEach((box) => {
                const initialState = dragContext.initialStates.get(box);
                let newX = initialState.worldX + dx_world;
                let newY = initialState.worldY + dy_world;
                if (e.ctrlKey) {
                  newX = Math.round(newX / GRID_CELL_SIZE) * GRID_CELL_SIZE;
                  newY = Math.round(newY / GRID_CELL_SIZE) * GRID_CELL_SIZE;
                }
                box.worldX = newX;
                box.worldY = newY;
              });
            }
            updateUI();
          }
          if (!isPanning) updateCursor(pos);
        }

        function onPointerUp(e) {
          if (isPanning) {
            isPanning = false;
            if (!isSpacebarDown) updateCursor(getMousePos(e));
            return;
          }
          if (isBoxSelecting) {
            selectionBoxElement.style.display = 'none';
            isBoxSelecting = false;
            const rect = editorCanvas.getBoundingClientRect();
            const boxRect = {
              left: Math.min(selectionStartPoint.x, e.clientX) - rect.left,
              right: Math.max(selectionStartPoint.x, e.clientX) - rect.left,
              top: Math.min(selectionStartPoint.y, e.clientY) - rect.top,
              bottom: Math.max(selectionStartPoint.y, e.clientY) - rect.top,
            };
            const objectsInBox = hitboxes.filter((box) => {
              const screenPos = worldToScreen({x: box.worldX + box.worldW / 2, y: box.worldY + box.worldH / 2});
              return screenPos.x >= boxRect.left && screenPos.x <= boxRect.right && screenPos.y >= boxRect.top && screenPos.y <= boxRect.bottom;
            });
            setSelection(objectsInBox, e.ctrlKey, true);
          }
          dragTarget = null;
          isResizing = false;
        }

        function getMousePos(evt) {
          const rect = editorCanvas.getBoundingClientRect();
          return {x: evt.clientX - rect.left, y: evt.clientY - rect.top};
        }

        function getHitboxAt(x, y) {
          for (let i = hitboxes.length - 1; i >= 0; i--) {
            const b = hitboxes[i];
            const screenPos = worldToScreen({x: b.worldX, y: b.worldY + b.worldH});
            const screenW = b.worldW * PIXELS_PER_UNIT;
            const screenH = b.worldH * PIXELS_PER_UNIT;
            if (x >= screenPos.x && x <= screenPos.x + screenW && y >= screenPos.y && y <= screenPos.y + screenH) return b;
          }
          return null;
        }

        function getResizeHandlePositions(b) {
          const tl = worldToScreen({x: b.worldX, y: b.worldY + b.worldH});
          const br = worldToScreen({x: b.worldX + b.worldW, y: b.worldY});
          return {
            nw: {x: tl.x, y: tl.y},
            ne: {x: br.x, y: tl.y},
            sw: {x: tl.x, y: br.y},
            se: {x: br.x, y: br.y},
            n: {x: (tl.x + br.x) / 2, y: tl.y},
            s: {x: (tl.x + br.x) / 2, y: br.y},
            w: {x: tl.x, y: (tl.y + br.y) / 2},
            e: {x: br.x, y: (tl.y + br.y) / 2},
          };
        }

        function getResizeHandleAt(x, y, box) {
          const pos = getResizeHandlePositions(box);
          const m = 6;
          for (const h in pos) {
            if (x >= pos[h].x - m && x <= pos[h].x + m && y >= pos[h].y - m && y <= pos[h].y + m) return h;
          }
          return null;
        }

        function resizeTarget(box, initialState, dx_world, dy_world, ctrlKey) {
          let {worldX, worldY, worldW, worldH} = initialState;

          if (resizeHandle.includes('w')) {
            worldX += dx_world;
            worldW -= dx_world;
          } else if (resizeHandle.includes('e')) {
            worldW += dx_world;
          }

          if (resizeHandle.includes('n')) {
            worldH += dy_world;
          } else if (resizeHandle.includes('s')) {
            worldY += dy_world;
            worldH -= dy_world;
          }

          if (ctrlKey) {
            if (resizeHandle.includes('w')) {
              const rightEdge = initialState.worldX + initialState.worldW;
              worldX = Math.round(worldX / GRID_CELL_SIZE) * GRID_CELL_SIZE;
              worldW = rightEdge - worldX;
            } else if (resizeHandle.includes('e')) {
              const rightEdge = initialState.worldX + worldW;
              worldW = Math.round(rightEdge / GRID_CELL_SIZE) * GRID_CELL_SIZE - initialState.worldX;
            }
            if (resizeHandle.includes('s')) {
              const topEdge = initialState.worldY + initialState.worldH;
              worldY = Math.round(worldY / GRID_CELL_SIZE) * GRID_CELL_SIZE;
              worldH = topEdge - worldY;
            } else if (resizeHandle.includes('n')) {
              const topEdge = initialState.worldY + worldH;
              worldH = Math.round(topEdge / GRID_CELL_SIZE) * GRID_CELL_SIZE - initialState.worldY;
            }
          }

          Object.assign(box, {worldX, worldY, worldW, worldH});
        }

        function updateCursor(pos) {
          const handle = selectedHitboxes.length === 1 ? getResizeHandleAt(pos.x, pos.y, selectedHitboxes[0]) : null;
          if (handle) {
            if (handle === 'nw' || handle === 'se') editorCanvas.style.cursor = 'nwse-resize';
            else if (handle === 'ne' || handle === 'sw') editorCanvas.style.cursor = 'nesw-resize';
            else if (handle.includes('n') || handle.includes('s')) editorCanvas.style.cursor = 'ns-resize';
            else editorCanvas.style.cursor = 'ew-resize';
          } else if (getHitboxAt(pos.x, pos.y)) {
            editorCanvas.style.cursor = 'move';
          } else if (isSpacebarDown) {
            editorCanvas.style.cursor = 'grab';
          } else {
            editorCanvas.style.cursor = 'default';
          }
        }

        function setSelection(boxes, ctrlKey = false, shiftKey = false) {
          const newSelection = Array.isArray(boxes) ? boxes : boxes ? [boxes] : [];
          if (ctrlKey) {
            newSelection.forEach((box) => {
              const index = selectedHitboxes.indexOf(box);
              if (index > -1) selectedHitboxes.splice(index, 1);
              else selectedHitboxes.push(box);
            });
          } else if (shiftKey) {
            newSelection.forEach((box) => {
              if (!selectedHitboxes.includes(box)) selectedHitboxes.push(box);
            });
          } else {
            selectedHitboxes = newSelection;
          }
          updateUI();
        }

        function clearAsset() {
          asset = null;
          hitboxes = [];
          setSelection([]);
          while (mechaGroup.children.length > 0) mechaGroup.remove(mechaGroup.children[0]);
          gridHelper.visible = true;
          webglCanvas.classList.remove('bg-grid');
          updateUI();
        }

        function addSprite(image, src) {
          clearAsset();
          asset = {type: 'sprite', image, src};
          gridHelper.visible = false;
          webglCanvas.classList.add('bg-grid');
          updateUI();
        }

        function loadMecJson(jsonContent, fileName) {
          clearAsset();
          try {
            const sceneData = JSON.parse(jsonContent);
            const loader = new THREE.BufferGeometryLoader();
            sceneData.objects.forEach((data) => {
              let geometry;
              const params = data.geometryParameters;
              switch (data.geometryType) {
                case 'Box':
                  geometry = new THREE.BoxGeometry(params?.width, params?.height, params?.depth);
                  break;
                case 'Sphere':
                  geometry = new THREE.SphereGeometry(params?.radius, params?.widthSegments, params?.heightSegments);
                  break;
                case 'Cone':
                  geometry = new THREE.ConeGeometry(params?.radius, params?.height, params?.radialSegments);
                  break;
                case 'Cylinder':
                case 'Prism':
                  geometry = new THREE.CylinderGeometry(params?.radiusTop, params?.radiusBottom, params?.height, params?.radialSegments);
                  break;
                case 'Custom':
                  if (params) geometry = loader.parse(params);
                  break;
                default:
                  return;
              }
              if (geometry) {
                const material = new THREE.MeshStandardMaterial({color: data.material.color, metalness: data.material.metalness, emissive: data.material.emissive, side: THREE.DoubleSide});
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.fromArray(data.position);
                mesh.rotation.fromArray(data.rotation);
                mesh.scale.fromArray(data.scale);
                mechaGroup.add(mesh);
              }
            });
            if (!mechaGroup.children.length) {
              alert('表示可能なジオメトリがありません。');
              return;
            }
            asset = {type: 'model', name: fileName, json: jsonContent};
            gridHelper.visible = true;
            webglCanvas.classList.remove('bg-grid');
            if (!guideDef) setGuide('player');

            const sideViewRotation = -Math.PI / 2;
            mechaGroup.rotation.y = sideViewRotation;

            rotationYSlider.value = THREE.MathUtils.radToDeg(sideViewRotation);

            updateUI();
          } catch (e) {
            alert('JSONのパースに失敗しました。');
            console.error(e);
          }
        }

        function updateUI() {
          deleteAssetBtn.disabled = !asset;
          modelControls.style.display = asset && asset.type === 'model' ? 'block' : 'none';
          exportFighterJsonBtn.disabled = !(asset && asset.type === 'model');
          exportBtn.disabled = !(asset && asset.type === 'sprite' && hitboxes.length > 0);
          deleteHitboxBtn.disabled = selectedHitboxes.length === 0;

          if (selectedHitboxes.length === 1) {
            const box = selectedHitboxes[0];
            propertiesPanel.style.display = 'block';
            propInputs.offsetX.value = box.worldX.toFixed(3);
            propInputs.offsetY.value = box.worldY.toFixed(3);
            propInputs.width.value = box.worldW.toFixed(3);
            propInputs.height.value = box.worldH.toFixed(3);
          } else {
            propertiesPanel.style.display = 'none';
          }
          updateJsonOutput();
        }

        function updateJsonOutput() {
          const o = hitboxes.map((b) => ({offsetX: parseFloat(b.worldX.toFixed(3)), offsetY: parseFloat(b.worldY.toFixed(3)), width: parseFloat(b.worldW.toFixed(3)), height: parseFloat(b.worldH.toFixed(3))}));
          jsonOutput.value = JSON.stringify(o, null, 2);
        }

        function setGuide(type) {
          guideDef = type ? GUIDE_DEFINITIONS[type] : null;
          [guidePlayerBtn, guideZakoBtn, guideBossBtn].forEach((b) => b.classList.remove('active'));
          if (type) document.getElementById(`guide${type.charAt(0).toUpperCase() + type.slice(1)}Btn`).classList.add('active');
        }

        imageLoader.addEventListener('change', (e) => {
          if (e.target.files[0]) {
            const reader = new FileReader();
            reader.onload = (event) => {
              const img = new Image();
              img.onload = () => addSprite(img, event.target.result);
              img.src = event.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
            e.target.value = '';
          }
        });
        mecJsonLoader.addEventListener('change', (e) => {
          if (e.target.files[0]) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = (re) => loadMecJson(re.target.result, file.name);
            reader.readAsText(file);
            e.target.value = '';
          }
        });
        deleteAssetBtn.addEventListener('click', clearAsset);
        rotationYSlider.addEventListener('input', (e) => {
          if (mechaGroup) mechaGroup.rotation.y = THREE.MathUtils.degToRad(e.target.value);
        });
        rotationXSlider.addEventListener('input', (e) => {
          if (mechaGroup) mechaGroup.rotation.x = THREE.MathUtils.degToRad(e.target.value);
        });

        addHitboxBtn.addEventListener('click', () => {
          const definition = guideDef || GUIDE_DEFINITIONS.player;
          const newBox = {worldX: -definition.w / 2, worldY: 0, worldW: definition.w, worldH: definition.h};
          hitboxes.push(newBox);
          setSelection([newBox]);
        });
        deleteHitboxBtn.addEventListener('click', () => {
          hitboxes = hitboxes.filter((box) => !selectedHitboxes.includes(box));
          setSelection([]);
        });

        rotationYSlider.addEventListener('input', updateRotationTooltip);
        rotationYSlider.addEventListener('mousedown', updateRotationTooltip);
        rotationYSlider.addEventListener('mouseup', () => {
          rotationYTooltip.style.display = 'none';
        });
        rotationYSlider.addEventListener('mouseleave', () => {
          rotationYTooltip.style.display = 'none';
        });

        Object.values(propInputs).forEach((input) =>
          input.addEventListener('input', (e) => {
            if (selectedHitboxes.length === 1) {
              const box = selectedHitboxes[0];
              box.worldX = parseFloat(propInputs.offsetX.value) || 0;
              box.worldY = parseFloat(propInputs.offsetY.value) || 0;
              box.worldW = parseFloat(propInputs.width.value) || 0;
              box.worldH = parseFloat(propInputs.height.value) || 0;
              updateUI();
            }
          })
        );

        guidePlayerBtn.addEventListener('click', () => setGuide('player'));
        guideZakoBtn.addEventListener('click', () => setGuide('zako'));
        guideBossBtn.addEventListener('click', () => setGuide('boss'));
        guideClearBtn.addEventListener('click', () => setGuide(null));

        copyJsonBtn.addEventListener('click', () => navigator.clipboard.writeText(jsonOutput.value).then(() => alert('JSONをコピーしました！')));

        saveHitboxTemplateBtn.addEventListener('click', () => {
          const name = hitboxTemplateNameInput.value.trim();
          if (!name || hitboxes.length === 0) return;
          const templates = JSON.parse(localStorage.getItem(STORAGE_KEYS.HITBOX_TEMPLATES) || '{}');
          templates[name] = hitboxes.map((box) => ({...box}));
          localStorage.setItem(STORAGE_KEYS.HITBOX_TEMPLATES, JSON.stringify(templates));
          alert(`テンプレート「${name}」を保存しました。`);
          populateHitboxTemplates();
        });

        function populateHitboxTemplates() {
          hitboxTemplateList.innerHTML = '';
          const templates = JSON.parse(localStorage.getItem(STORAGE_KEYS.HITBOX_TEMPLATES) || '{}');
          for (const name in templates) {
            const row = document.createElement('div');
            row.style.cssText = 'display:flex; gap:10px; margin-bottom:10px;';
            const loadBtn = document.createElement('button');
            loadBtn.textContent = `「${name}」をロード`;
            loadBtn.style.flexGrow = '1';
            loadBtn.onclick = () => {
              if (confirm(`現在のヒットボックスをクリアし、「${name}」をロードしますか？`)) {
                hitboxes = templates[name].map((b) => ({...b}));
                setSelection([]);
              }
            };
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = '削除';
            deleteBtn.style.backgroundColor = '#d9534f';
            deleteBtn.onclick = () => {
              if (confirm(`テンプレート「${name}」を削除しますか？`)) {
                delete templates[name];
                localStorage.setItem(STORAGE_KEYS.HITBOX_TEMPLATES, JSON.stringify(templates));
                populateHitboxTemplates();
              }
            };
            row.appendChild(loadBtn);
            row.appendChild(deleteBtn);
            hitboxTemplateList.appendChild(row);
          }
        }

        exportBtn.addEventListener('click', () => {
          if (!asset || asset.type !== 'sprite') return alert('切り出しには画像スプライトが必要です。');
          const bbox = hitboxes.reduce(
            (bb, box) => {
              const screenPos = worldToScreen({x: box.worldX, y: box.worldY + box.worldH});
              const screenW = box.worldW * PIXELS_PER_UNIT;
              const screenH = box.worldH * PIXELS_PER_UNIT;
              return {minX: Math.min(bb.minX, screenPos.x), minY: Math.min(bb.minY, screenPos.y), maxX: Math.max(bb.maxX, screenPos.x + screenW), maxY: Math.max(bb.maxY, screenPos.y + screenH)};
            },
            {minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity}
          );
          const width = bbox.maxX - bbox.minX,
            height = bbox.maxY - bbox.minY;
          if (width <= 0 || height <= 0) return alert('有効なヒットボックスがありません。');
          const tempCanvas = document.createElement('canvas');
          tempCanvas.width = width;
          tempCanvas.height = height;
          const tempCtx = tempCanvas.getContext('2d');
          const spriteX = (editorCanvas.width - asset.image.width) / 2;
          const spriteY = (editorCanvas.height - asset.image.height) / 2;
          tempCtx.drawImage(asset.image, bbox.minX - spriteX, bbox.minY - spriteY, width, height, 0, 0, width, height);
          const link = document.createElement('a');
          link.download = 'cropped_sprite.png';
          link.href = tempCanvas.toDataURL('image/png');
          link.click();
        });

        openSaveLoadModalBtn.addEventListener('click', () => {
          saveLoadModal.style.display = 'flex';
          populateStateSlots();
        });
        closeModalBtn.addEventListener('click', () => {
          saveLoadModal.style.display = 'none';
        });

        function saveState(slot) {
          const serializableAsset = asset ? (asset.type === 'sprite' ? {type: 'sprite', src: asset.src} : {type: 'model', name: asset.name, json: asset.json}) : null;
          const state = {asset: serializableAsset, hitboxes};
          localStorage.setItem(STORAGE_KEYS.STATE_PREFIX + slot, JSON.stringify(state));
          alert(`スロット ${slot} に保存しました。`);
          populateStateSlots();
        }
        function loadState(slot) {
          const stateJSON = localStorage.getItem(STORAGE_KEYS.STATE_PREFIX + slot);
          if (!stateJSON) return;
          const state = JSON.parse(stateJSON);
          clearAsset();
          hitboxes = state.hitboxes || [];
          if (state.asset) {
            if (state.asset.type === 'sprite') {
              const img = new Image();
              img.onload = () => addSprite(img, state.asset.src);
              img.src = state.asset.src;
            } else if (state.asset.type === 'model') {
              loadMecJson(state.asset.json, state.asset.name);
            }
          }
          alert(`スロット ${slot} からロードしました。`);
          closeModalBtn.click();
        }
        function populateStateSlots() {
          const slotList = saveLoadModal.querySelector('.slot-list');
          slotList.innerHTML = '';
          for (let i = 1; i <= 6; i++) {
            const hasData = !!localStorage.getItem(STORAGE_KEYS.STATE_PREFIX + i);
            const saveBtn = document.createElement('button');
            saveBtn.textContent = `スロット${i}に保存`;
            saveBtn.onclick = () => saveState(i);
            const loadBtn = document.createElement('button');
            loadBtn.textContent = `スロット${i}から読込`;
            loadBtn.onclick = () => loadState(i);
            loadBtn.disabled = !hasData;
            slotList.appendChild(saveBtn);
            slotList.appendChild(loadBtn);
          }
        }

        [assetModeBtn, hitboxModeBtn].forEach((btn) =>
          btn.addEventListener('click', () => {
            const isAssetMode = btn.id === 'assetModeBtn';
            assetModeBtn.classList.toggle('active', isAssetMode);
            hitboxModeBtn.classList.toggle('active', !isAssetMode);
            assetModePanel.style.display = isAssetMode ? 'block' : 'none';
            hitboxModePanel.style.display = !isAssetMode ? 'block' : 'none';
            setSelection([]);
          })
        );

        exportFighterJsonBtn.addEventListener('click', () => {
          if (!asset || asset.type !== 'model') {
            alert('MECモデルが読み込まれていません。');
            return;
          }

          const outputFilename = prompt('書き出すファイル名を入力してください:', 'fighter.json');
          if (!outputFilename) return;

          const fighterData = {
            modelFile: asset.name,
            hitboxes: hitboxes.map((b) => ({
              offsetX: parseFloat(b.worldX.toFixed(3)),
              offsetY: parseFloat(b.worldY.toFixed(3)),
              width: parseFloat(b.worldW.toFixed(3)),
              height: parseFloat(b.worldH.toFixed(3)),
            })),
          };

          const jsonString = JSON.stringify(fighterData, null, 2);
          const blob = new Blob([jsonString], {type: 'application/json'});
          const link = document.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = outputFilename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });

        // --- Final Initialization ---
        init();
        updateUI();
        populateHitboxTemplates();
        assetModeBtn.click();
      });
    </script>
  </body>
</html>
