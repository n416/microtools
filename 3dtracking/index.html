<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MediaPipe ペンギンデモ</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
    .container {
      position: relative;
      width: 640px;
      height: 480px;
      border: 2px solid #333;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      background-color: black;
    }
    #webcam {
      display: none;
    }
    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    h1 {
        margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <h1>ペンギンに変身！</h1>
  <div class="container">
    <video id="webcam"></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

<script>
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    const beakImage = new Image();
    beakImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEwAACxMBAJqcGAAAA6tJREFUeJzt3D1u1EAUhuFnZ18AFyRdpE6Vr0Kk4hvoEylS5U/oEl0pUnJKlFxAnwB/gbsCAgJ+SSQx1t7Ozj6L9ySLZOO1Z8/szI53cpcDAAAAAAAAAAAAAAAAgMBe5KkHk/P5R9e5T+4++Tq5uDzl43z24c3N/R87383nL1r/5QG44EHyWbJ2a2sv+XLyX/Y+8sXk+fyr+YkH4IIPk4/37u5+8P+V/7d/u/fRe5OfJt/OflsC/A2Q4D8DSf43QIL/DSDB/wZI8L8BkvxvgAT/GyDB/wZI8L8BkvxvgAT/GyDB/wZI8L8BkvxvgAT/GyDB/wZI8L8BkvxvgAT/G3iA/D65+3g6+S/7eDI5eR9t/nng+vP5h9f5R+8eA3wQ/k/OPgG+B8gAEwwgwwAyDCDDAJIMIMMA0gwwAyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIMIAMg8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADANIAIMA8gwgAwDyDCADAN+AnB08uP428mvk2d3H4/3P3uePPiK/Pz8r6v8xN8/gV/kdwMAAAAAAAAAAAAAAACAwH/5Azj7O7F4xY4ZAAAAAElFTkSuQmCC';
    
    const SMOOTHING_FACTOR = 0.8;
    let smoothedLandmarks = null;

    beakImage.onload = () => {
      camera.start();
    };
    beakImage.onerror = () => {
      console.error("画像の読み込みに失敗しました。");
    };

    function onResults(results) {
      canvasElement.width = videoElement.videoWidth;
      canvasElement.height = videoElement.videoHeight;
      const canvasWidth = canvasElement.width;
      const canvasHeight = canvasElement.height;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      canvasCtx.fillStyle = '#000000';
      canvasCtx.fillRect(0, 0, canvasWidth, canvasHeight);

      canvasCtx.translate(canvasWidth, 0);
      canvasCtx.scale(-1, 1);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        if (smoothedLandmarks === null) {
          smoothedLandmarks = landmarks;
        } else {
          smoothedLandmarks.forEach((prev, i) => {
            prev.x = prev.x * SMOOTHING_FACTOR + landmarks[i].x * (1 - SMOOTHING_FACTOR);
            prev.y = prev.y * SMOOTHING_FACTOR + landmarks[i].y * (1 - SMOOTHING_FACTOR);
            prev.z = prev.z * SMOOTHING_FACTOR + landmarks[i].z * (1 - SMOOTHING_FACTOR);
          });
        }
        
        drawConnectors(canvasCtx, smoothedLandmarks, FACEMESH_CONTOURS, {color: '#30FF30', lineWidth: 1});

        drawPenguinParts(smoothedLandmarks, canvasWidth, canvasHeight);
      }
      canvasCtx.restore();
    }
    
    // ★★★ 傾きや大きさの計算をなくした、シンプルな描画関数 ★★★
    function drawPenguinParts(landmarks, width, height) {
        // 鼻の先端（1番）の座標を取得
        const beakAnchor = landmarks[1];
        if (!beakAnchor) return; // 念のためデータがあるか確認

        const beakX = beakAnchor.x * width;
        const beakY = beakAnchor.y * height;

        // 大きさを100pxに固定（テスト用）
        const beakSize = 100;

        // 傾きの計算はせず、そのまま描画
        // 画像の中心が鼻先にくるように座標をずらす
        canvasCtx.drawImage(beakImage, beakX - beakSize / 2, beakY - beakSize / 2, beakSize, beakSize);
    }

    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);

    const camera = new Camera(videoElement, {
      onFrame: async () => { await faceMesh.send({image: videoElement}); },
      width: 640, height: 480, facingMode: 'user'
    });
</script>
</body>
</html>