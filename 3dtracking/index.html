<!DOCTYPE html>
<html lang="ja">

<head>

  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ãƒšãƒ³ã‚®ãƒ³å¤‰èº«ã‚«ãƒ¡ãƒ©</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
    }

    h1 {
      color: white;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      font-size: 2em;
    }

    .container {
      position: relative;
      width: 100%;
      max-width: 640px;
      background: white;
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      padding-bottom: 75%;
      /* 4:3 aspect ratio */
      background: #000;
      border-radius: 10px;
      overflow: hidden;
    }

    #webcam {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: none;
    }

    #output_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #status {
      margin-top: 15px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 8px;
      text-align: center;
      font-size: 14px;
      color: #666;
    }

    #status.loading {
      color: #667eea;
    }

    #status.ready {
      color: #10b981;
    }

    #status.error {
      color: #ef4444;
    }
  </style>
</head>

<body>
  <h1>ğŸ§ ãƒšãƒ³ã‚®ãƒ³ã«å¤‰èº«ï¼</h1>
  <div class="container">
    <div class="video-wrapper">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="output_canvas"></canvas>
    </div>
    <div id="status" class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>

  <script>
    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusElement = document.getElementById('status');

    let faceMesh;
    let camera;
    let isReady = false;

    function updateStatus(message, className) {
      statusElement.textContent = message;
      statusElement.className = className;
    }

    function onResults(results) {
      if (!isReady) return;

      const width = videoElement.videoWidth;
      const height = videoElement.videoHeight;
      canvasElement.width = width;
      canvasElement.height = height;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, width, height);
      canvasCtx.translate(width, 0); // æ˜ åƒã‚’å·¦å³åè»¢
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(videoElement, 0, 0, width, height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];
        drawPenguinBeak(landmarks, width, height);
      }
      canvasCtx.restore();
    }

    // â˜…â˜…â˜… æœ€çµ‚ä¿®æ­£ï¼šæ¨ªå‘ãã«å¿œã˜ã¦ã‚·ã‚¢ãƒ¼å¤‰å½¢ï¼ˆå‰ªæ–­å¤‰å½¢ï¼‰ã‚’é©ç”¨ â˜…â˜…â˜…
    function drawPenguinBeak(landmarks, width, height) {
      const noseBottom = landmarks[2];
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const noseTip = landmarks[4]; // é¼»å…ˆã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚‚è§’åº¦è¨ˆç®—ã«åˆ©ç”¨

      if (!noseBottom || !leftEye || !rightEye || !noseTip) return;

      const eyeDistX = (leftEye.x - rightEye.x) * width;
      const eyeDistY = (leftEye.y - rightEye.y) * height;
      const eyeDistance = Math.sqrt(eyeDistX * eyeDistX + eyeDistY * eyeDistY);

      const beakHeight = eyeDistance * 1.5;
      const beakWidth = eyeDistance * 1.4;

      const anchorX = noseBottom.x * width;
      const anchorY = noseBottom.y * height;

      canvasCtx.save();
      canvasCtx.translate(anchorX, anchorY); // é¼»ã®ä¸‹ã‚’åŸç‚¹ã«ç§»å‹•

      // â˜…é¡”ã®æ¨ªå‘ãã®è§’åº¦ã‚’è¨ˆç®—
      // é¼»å…ˆ(4)ã¨é¼»ã®ä¸‹(2)ã®Xåº§æ¨™ã®å·®åˆ†ã‹ã‚‰ã€é¡”ã®å·¦å³ã¸ã®å‚¾ãã‚’æ¨å®š
      const faceTurnAngleRad = Math.atan2((noseTip.x - noseBottom.x) * width, beakHeight); // Yè»¸æ–¹å‘ã®åŸºæº–ã¨ã—ã¦beakHeightã‚’åˆ©ç”¨
      const maxShearFactor = 0.5; // æœ€å¤§ã®ã‚·ã‚¢ãƒ¼å¼·åº¦ (èª¿æ•´å¯èƒ½)
      const shearFactor = faceTurnAngleRad / (Math.PI / 2) * maxShearFactor; // 90åº¦ã§maxShearFactorã¨ãªã‚‹ã‚ˆã†ã«èª¿æ•´

      // ã‚·ã‚¢ãƒ¼å¤‰å½¢ã‚’é©ç”¨
      // ctx.transform(scaleX, skewY, skewX, scaleY, translateX, translateY);
      // skewXã«shearFactorã‚’é©ç”¨ã™ã‚‹ã“ã¨ã§ã€Xè»¸æ–¹å‘ã®å‚¾ãï¼ˆæ¨ªå‘ãï¼‰ã‚’è¡¨ç¾
      canvasCtx.transform(1, 0, shearFactor, 1, 0, 0);

      // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ (ã‚·ã‚¢ãƒ¼å¤‰å½¢å¾Œã‚‚å…‰ã®æ–¹å‘ãŒå¤‰ã‚ã‚‰ãªã„ã‚ˆã†ã«ã€ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·ç‚¹ã‚’ä¸­å¿ƒã«å›ºå®š)
      const gradient = canvasCtx.createLinearGradient(-beakWidth / 2, 0, beakWidth / 2, 0);
      gradient.addColorStop(0, '#FFB74D'); // å·¦å´ã‚’æ˜ã‚‹ã„ã‚ªãƒ¬ãƒ³ã‚¸
      gradient.addColorStop(0.5, '#FFA726'); // ä¸­å¤®ã‚’ãƒ¡ã‚¤ãƒ³ã®ã‚ªãƒ¬ãƒ³ã‚¸
      gradient.addColorStop(1, '#FB8C00'); // å³å´ã‚’å°‘ã—æš—ã„ã‚ªãƒ¬ãƒ³ã‚¸

      // ä¸‰è§’å½¢ã‚’æç”»
      canvasCtx.beginPath();
      canvasCtx.moveTo(-beakWidth / 2, 0); // å·¦ä¸Š
      canvasCtx.lineTo(beakWidth / 2, 0); // å³ä¸Š
      canvasCtx.lineTo(0, beakHeight); // ä¸‹ã®é ‚ç‚¹
      canvasCtx.closePath();

      canvasCtx.fillStyle = gradient;
      canvasCtx.fill();

      canvasCtx.strokeStyle = '#BF6A00';
      canvasCtx.lineWidth = 2;
      canvasCtx.stroke();

      canvasCtx.restore();
    }

    async function initFaceMesh() {
      try {
        updateStatus('Face Mesh ã‚’åˆæœŸåŒ–ä¸­...', 'loading');
        faceMesh = new FaceMesh({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
        });
        faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: false,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onResults);
        updateStatus('ã‚«ãƒ¡ãƒ©ã‚’èµ·å‹•ä¸­...', 'loading');
        setTimeout(() => initCamera(), 500);
      } catch (error) {
        console.error('Face MeshåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        updateStatus('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message, 'error');
      }
    }

    async function initCamera() {
      try {
        camera = new Camera(videoElement, {
          onFrame: async () => {
            if (faceMesh && isReady) {
              await faceMesh.send({
                image: videoElement
              });
            }
          },
          width: 640,
          height: 480
        });
        await camera.start();
        isReady = true;
        updateStatus('æº–å‚™å®Œäº†ï¼é¡”ã‚’æ˜ ã—ã¦ãã ã•ã„ ğŸ§', 'ready');
      } catch (error) {
        console.error('ã‚«ãƒ¡ãƒ©èµ·å‹•ã‚¨ãƒ©ãƒ¼:', error);
        updateStatus('ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ã¦ãã ã•ã„ã€‚', 'error');
      }
    }

    async function initialize() {
      try {
        updateStatus('åˆæœŸåŒ–ä¸­...', 'loading');
        await initFaceMesh();
      } catch (error) {
        console.error('åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        updateStatus('ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initialize);
    } else {
      initialize();
    }
  </script>
</body>

</html>